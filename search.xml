<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TLS1.3 概述---protocol</title>
      <link href="/2020/04/08/TLS1.3%20%E6%A6%82%E8%BF%B0---protocol/"/>
      <url>/2020/04/08/TLS1.3%20%E6%A6%82%E8%BF%B0---protocol/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200407154557900.png#pic_center" alt="tls1.3"><br>TLS1.3的最终版本，在2018年8月发布，它包含着很多不同以往版本的改进，相对于之前版本安全性以及性能具有极大的提高，同时它也具备了更多的扩展和握手模式，那么从实现完整TLS1.3结构的角度去学习TLS，我们应该从哪些方面入手呢？<br><br/><br> <a id="more"></a></p><h2 id="什么是TLS"><a href="#什么是TLS" class="headerlink" title="什么是TLS"></a>什么是TLS</h2><hr><p>TLS代表传输层安全性，并且是SSL（安全套接字层）的后继者。TLS提供了Web浏览器和服务器之间的安全通信。连接本身是安全的，因为使用对称密码术对传输的数据进行加密。密钥是为每个连接唯一生成的，并且基于在会话开始时协商的共享机密（也称为TLS握手）。<code>HTTP + TLS = HTTPS</code></p><h3 id="TLS历史"><a href="#TLS历史" class="headerlink" title="TLS历史"></a>TLS历史</h3><p><img src="https://img-blog.csdnimg.cn/20200407165241785.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70#pic_center" alt="history"><br><br/></p><h2 id="TLS1-2"><a href="#TLS1-2" class="headerlink" title="TLS1.2"></a>TLS1.2</h2><hr><h3 id="TLS1-2握手原理"><a href="#TLS1-2握手原理" class="headerlink" title="TLS1.2握手原理"></a>TLS1.2握手原理</h3><p><img src="https://img-blog.csdnimg.cn/20200407170442936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70#pic_center" alt="tls1.2"><br>握手的过程主要包括两部分：</p><ul><li>参数协商<br>  客户端向服务器发送client Hello消息，里面包含client所支持的参数（密码套件等等），还包含一些有用的参数（version、random、sessionId等等），server会从中选取自己支持的密码套件、版本，通过server Hello发送给client，其中也包含一个随机数还有一些其他字段。</li><li>密钥交换<br>  之后server会通过Server Key Exchange消息向client发送自己用于协商的公钥，用于协商的算法是：ECDHE或DHE，同样client通过 Client Key Exchange 发送自己的公钥，这样双方都具有了彼此的公钥，用它们生成临时私钥。client在收到server的Certificate消息之后会验证server的身份，验证通过才会发送Client Key Exchange，其中还包含着pre-Masterkey，是对client生成的随机数加密得来，最后使用三个随机数生成Masterkey用于会话密钥。  </li></ul><p>观察图片我们可以看出，TLS1.2整个握手过程需要2个RTT时间，而且每次握手都用到了非对称加密算法签名或者解密的操作，比较耗时和耗 CPU，每次都要传输证书，证书比较大会消耗带宽。    </p><ul><li>RTT<br>  Round-Trip Time，往返时延，在计算机网络中它也是一个重知要的性能指标，它表示从发送端发道送数据开始，到发送端收到来自接收端的确认版（接收端收到数据后便立即发送确认），总共经历的时延。</li></ul><h3 id="TLS1-2会话恢复"><a href="#TLS1-2会话恢复" class="headerlink" title="TLS1.2会话恢复"></a>TLS1.2会话恢复</h3><ul><li>SessionID<br>  将协商好的会话参数缓存在客户端与服务器中，client下次握手时会带上上次握手的SessionID，server对其查询，若存在直接复用。</li><li>SessionTicket<br>  server将协商好的会话参数和密钥加密发送给客户端，client下次握手会将这个SessionTicket带上，如果server解密成功就复用上次的会话参数和密钥。   </li></ul><p>在TLS1.3中没有了SessionID这种会话恢复模式，但是在client Hello中还会存在该字段，主要是为了兼容版本。并且在SessionTicket模式中，添加了Ticket age，指的是会话是存在时间限制的，如果超过了该时间，那么也就不能进行会话恢复。    </p><p><img src="https://img-blog.csdnimg.cn/2020040718531413.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70#pic_center" alt="sessionid"><br>我们可以看到，使用SessionID恢复会话的时候，需要花费1个RTT的时间，在TLS1.3中一定情况下恢复会话只需要花费0个RTT!    </p><p>在握手的过程中很多数据都会临时计算，如果我们把这些数据提前计算出来，然后存入扩展当中，这样就可以减少握手的时间为1个RTT，TLS1.3实现的主要思想就是这样的。   </p><h2 id="TLS1-3"><a href="#TLS1-3" class="headerlink" title="TLS1.3"></a>TLS1.3</h2><hr><h3 id="TLS1-3握手"><a href="#TLS1-3握手" class="headerlink" title="TLS1.3握手"></a>TLS1.3握手</h3><p>更快的访问速度<br><img src="https://img-blog.csdnimg.cn/20200407193233929.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70#pic_center" alt="TLS1.2handshake"><br>这是一张TLS1.2的握手过程图片，前面也分析过，它需要2个RTT的时间才能完成整个握手过程，下面我们看一下TLS1.3的握手过程图：  </p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84MDA5Ny1jYTUzZDNkMDg2NDUwYjZiLnBuZw?x-oss-process=image/format,png#pic_center" alt="tls1.3extension"><br>我们会发现，其中存在一些以前版本从来没有出现过的extension，比如：key_share、signature_algorithms等等，这只是一部分，还包含很多扩展，我会一一细说。正因为这些扩展才使得TLS1.3的握手速度大大提高。    </p><p>注：</p><ul><li>+：上一消息的扩展消息  </li><li>*：可选发送</li><li>{}：用握手层流密钥加密</li><li>[]：用流密钥加密  </li></ul><h4 id="client-Hello"><a href="#client-Hello" class="headerlink" title="client Hello"></a>client Hello</h4><p>当client第一次连接server的时候，它需要向server发送client Hello 消息。    </p><p>clientHello消息的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">uint16 ProtocolVersion;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    opaque Random[<span class="number">32</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    uint8 CipherSuite[<span class="number">2</span>];    <span class="comment">/* Cryptographic suite selector */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        ProtocolVersion legacy_version = <span class="number">0x0303</span>;    <span class="comment">/* TLS v1.2 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        Random <span class="built_in">random</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        opaque legacy_session_id&lt;<span class="number">0.</span><span class="number">.32</span>&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        CipherSuite cipher_suites&lt;<span class="number">2.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-2</span>&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        opaque legacy_compression_methods&lt;<span class="number">1.</span><span class="number">.2</span>^<span class="number">8</span><span class="number">-1</span>&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        Extension extensions&lt;<span class="number">8.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    &#125; ClientHello;</span></pre></td></tr></table></figure><p>简单介绍一下比较重要的几个字段的含义：     </p><ul><li>legacy_version<br>在 TLS 以前的版本里，这个字段被用来版本协商和表示 Client 所能支持的 TLS 最高版本号。经验表明，很多 Server 并没有正确的实现版本协商，导致了 “version intolerance” —— Sever 拒绝了一些本来可以支持的 ClientHello 消息，只因为这些消息的版本号高于 Server 能支持的版本号。在TLS1.3中，设置了一个supported_version的扩展来表明client所支持的版本。legacy_version 字段必须设置成 0x0303，这是 TLS 1.2 的版本号。在 TLS 1.3 中的 ClientHello 消息中的 legacy_version 都设置成 0x0303，supported_versions 扩展设置成 0x0304。主要是为了兼容之前的TLS版本。</li><li>legacy_session_id<br>前面我也提到过，TLS1.3中不再使用SessionID进行会话恢复，这一特性已经和预共享密钥PSK合并了，设置这个字段的意义，主要也是为了兼容之前版本，如果 Client 有 TLS 1.3 版本之前的 Server 设置的缓存 Session ID，那么这个字段要填上这个 ID 值。兼容模式下，这个值必须是非空的，所以如果Client不能提供之前版本的值，那么需要重新生成一个32字节的值。   </li></ul><p>还有cipher_suites、legacy_compression_methods，包含的是Client支持的密码套件和压缩算法，压缩算法TLS1.3也已经不再支持了，这个字段主要还是为了兼容版本，对于每个 ClientHello，该向量必须包含一个设置为 0 的一个字节，它对应着 TLS 之前版本中的 null 压缩方法。  </p><h4 id="supported-groups"><a href="#supported-groups" class="headerlink" title="supported_groups"></a>supported_groups</h4><p>这个扩展表明了 Client 支持的用于密钥交换的命名组。按照优先级从高到低。这个扩展中的 “extension_data” 字段包含一个 “NamedGroupList” 值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">/* Elliptic Curve Groups (ECDHE) */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">         secp256r1(<span class="number">0x0017</span>), secp384r1(<span class="number">0x0018</span>), secp521r1(<span class="number">0x0019</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">         x25519(<span class="number">0x001D</span>), x448(<span class="number">0x001E</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">/* Finite Field Groups (DHE) */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">         ffdhe2048(<span class="number">0x0100</span>), ffdhe3072(<span class="number">0x0101</span>), ffdhe4096(<span class="number">0x0102</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">         ffdhe6144(<span class="number">0x0103</span>), ffdhe8192(<span class="number">0x0104</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">         <span class="comment">/* Reserved Code Points */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">         ffdhe_private_use(<span class="number">0x01FC</span>.<span class="number">.0</span>x01FF),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">         ecdhe_private_use(<span class="number">0xFE00</span>.<span class="number">.0</span>xFEFF),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">         (<span class="number">0xFFFF</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">     &#125; NamedGroup;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">         NamedGroup named_group_list&lt;<span class="number">2.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">     &#125; NamedGroupList;</span></pre></td></tr></table></figure><h4 id="key-share"><a href="#key-share" class="headerlink" title="key_share"></a>key_share</h4><p>这个扩展我觉得是TLS1.3的重大改变，它里面包含了Client对应于supported_groups中参数的公钥集，如果使用了曲线，则会表明所使用的曲线以及对应的公钥。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">       NamedGroup group;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">       opaque key_exchange&lt;<span class="number">1.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   &#125; KeyShareEntry;</span></pre></td></tr></table></figure><ul><li>group:<br>要交换的密钥的命名组。</li><li>key_exchange:<br>密钥交换信息。这个字段的内容由特定的组和相应的定义确定。主要包含特定组的公钥等信息。   </li></ul><p>在 ClientHello 消息中，”key_share” 扩展中的 “extension_data” 包含 KeyShareClientHello 值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        KeyShareEntry client_shares&lt;<span class="number">0.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &#125; KeyShareClientHello;</span></pre></td></tr></table></figure><ul><li>client_shares:<br>按照 Client 偏好降序顺序提供的 KeyShareEntry 值列表。  </li></ul><p>在golang中该结构的实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KeyShareEntry <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">group NamedGroup</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">length<span class="keyword">uint16</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">keyExchange[]<span class="keyword">byte</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> KeyShareClientHello <span class="keyword">struct</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">length <span class="keyword">uint16</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">clientShares[]KeyShareEntry</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>如果我们只实现椭圆曲线的话，首先需要选择要使用的椭圆曲线，之后再选取随机数生成公钥，将公钥存入keyExchange字段中，也就是说这个扩展已经将Client用于协商会话密钥的参数提前计算出来，并存储了起来，这与之前版本的形式server先选择参数，然后发给Client，然后Client再计算相比较，极大的节省了时间和握手过程中占用的CPU。  </p><p>Client 可以提供与其提供的 support groups 一样多数量的 KeyShareEntry 的值。每个值都代表了一组密钥交换参数。例如，Client 可能会为多个椭圆曲线或者多个 FFDHE 组提供 shares。每个 KeyShareEntry 中的 key_exchange 值必须独立生成。Client 不能为相同的 group 提供多个 KeyShareEntry 值。Client 不能为，没有出现在 Client 的 “supported_group” 扩展中列出的 group 提供任何 KeyShareEntry 值。Server 会检查这些规则，如果违反了规则，立即发送 “illegal_parameter” alert 消息中止握手。  </p><p>当选用PSK密钥协商模式时，即使在supported_groups中不存在支持的算法也不会终止握手，这时候，server会向Client发送和serverhello具有相同结构的消息：HelloRetryRequest，它的目的主要是想让Client作出一些改变以使得握手正常进行，在这种情况下，在 HelloRetryRequest 消息中，”key_share” 扩展中的 “extension_data” 字段包含 KeyShareHelloRetryRequest 值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">      NamedGroup selected_group;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  &#125; KeyShareHelloRetryRequest;</span></pre></td></tr></table></figure><ul><li>selected_group<br>表明server所选择的NamedGroup中组  </li></ul><p>Client收到此消息之后也会对其进行验证，selected_group是否在NamedGroup中出现了，selected_group 没有在原始的 ClientHello 中的 “key_share” 中出现过。如果上面 的检查都失败了，那么 Client 必须通过 “illegal_parameter” alert 消息来中止握手。否则，在发送新的 ClientHello 时，Client 必须将原始的 “key_share” 扩展替换为仅包含触发 HelloRetryRequest 的 selected_group 字段中指示的组,这个组中只包含新的 KeyShareEntry。  </p><p>在 ServerHello 消息中，”key_share” 扩展中的 “extension_data” 字段包含 KeyShareServerHello 值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        KeyShareEntry server_share;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    &#125; KeyShareServerHello;</span></pre></td></tr></table></figure><ul><li>server_share:<br>与 Client 共享的位于同一组的单个 KeyShareEntry 值。  </li></ul><p>我们再来看一下ECDHE的参数，对于 secp256r1，secp384r1 和 secp521r1，内容是以下结构体的序列化值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    uint8 legacy_form = <span class="number">4</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    opaque X[coordinate_length];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    opaque Y[coordinate_length];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125; UncompressedPointRepresentation;</span></pre></td></tr></table></figure><p>对端还要验证对方的公钥以确保为有效的点：</p><ul><li>验证公钥不是无穷大点</li><li>两个整数x、y中间有正确的间隔</li><li>x、y是椭圆曲线方程的正确的解</li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>TLS 1.3 中优化握手：</p><ul><li>client发送clientHello（extension）消息，extension中的support_groups中携带client支持的椭圆曲线的类型，并且在扩展key_share中计算出了相对应的公钥，一起发送给server</li><li>server收到clientHello后会首先选择相应的椭圆曲线参数计算自身的公钥，从key_share扩展中提取相应的公钥作为密钥协商的参数，计算主密钥，并且把自身计算出的公钥放到serverHello的扩展key_share中，然后发送serverHello等消息给client，Client从key_share中取出公钥计算主密钥。  </li></ul><h3 id="TLS1-3会话恢复"><a href="#TLS1-3会话恢复" class="headerlink" title="TLS1.3会话恢复"></a>TLS1.3会话恢复</h3><p>在本文前面我提到过TLS1.3已经不再使用SessionID进行会话恢复了，现在主要使用的是SessionTicket进行会话恢复，但是又不同于TLS1.2中使用SessionTicket进行会话恢复的过程，也做出了一些改变，或者说是进行了一些更新（PSK）。   </p><p><img src="https://img-blog.csdnimg.cn/20200408150844823.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70#pic_center" alt="tls1.3handshake"><br>会话恢复所花费的时间是1个RTT，这与整个的握手时间是一样的。在TLS1.3中采用的会话恢复机制是PSK它与SessionTicket有些类似，Client通过PSK发送被server加密的会话缓存参数，如果server解密成功就可以直接复用会话，不需要再重新传输证书和协商密钥了。</p><h4 id="密钥交换模式"><a href="#密钥交换模式" class="headerlink" title="密钥交换模式"></a>密钥交换模式</h4><ul><li>PSK-Only</li><li>(EC)DHE</li><li>PSK with (EC)DHE（暂时还没出现）</li></ul><h4 id="PSK-handshake"><a href="#PSK-handshake" class="headerlink" title="PSK handshake"></a>PSK handshake</h4><p>在使用PSK密钥交换模式时我们首先要了解几个ClientHello的其它扩展：</p><h5 id="Pre-Shared-Key-Exchange-Modes"><a href="#Pre-Shared-Key-Exchange-Modes" class="headerlink" title="Pre-Shared Key Exchange Modes"></a>Pre-Shared Key Exchange Modes</h5><p>为了使用PSK，client还需要发送Pre-Shared Key Exchange Modes扩展，它的含义是Client 仅支持使用具有这些模式的 PSK，这就限制了在这个 ClientHello 中提供的 PSK 的使用，也限制了 Server 通过 NewSessionTicket 提供的 PSK 的使用。<br>如果Client提供了 pre_shared_key扩展，那么就必须提供该扩展</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; psk_ke(<span class="number">0</span>), psk_dhe_ke(<span class="number">1</span>), (<span class="number">255</span>) &#125; PskKeyExchangeMode;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        PskKeyExchangeMode ke_modes&lt;<span class="number">1.</span><span class="number">.255</span>&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    &#125; PskKeyExchangeModes;</span></pre></td></tr></table></figure><ul><li>psk_ke:<br>仅 PSK 密钥建立。在这种模式下，Server 不能提供 key_share 值</li><li>psk_dhe_ke:<br>PSK 和 (EC)DHE 建立。在这种模式下，Client 和 Server 必须提供 key_share值。  </li></ul><p>这样的话就可以进行模式选择，并作出相应的改变。未来分配的任何值都必须要能保证传输的协议消息可以明确的标识 Server 选择的模式。目前 Server 选择的值由 ServerHello 中存在的 key_share 表示。   </p><h5 id="Pre-Shared-Key"><a href="#Pre-Shared-Key" class="headerlink" title="Pre-Shared Key"></a>Pre-Shared Key</h5><p>该扩展是用来协商标识的，该标识是与PSK密钥相关联的给定握手所使用的预共享密钥的标识。或者说是New Session Ticket+binders，由于在TLS1.3中，New Session Ticket可以在握手结束后可能多次发送，所以Pre-Shared Key可能会存储多组对应的值，下面我们具体来了解一下它的结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">          opaque identity&lt;<span class="number">1.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">          uint32 obfuscated_ticket_age;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">      &#125; PskIdentity;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">      opaque PskBinderEntry&lt;<span class="number">32.</span><span class="number">.255</span>&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      <span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">          PskIdentity identities&lt;<span class="number">7.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">          PskBinderEntry binders&lt;<span class="number">33.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">      &#125; OfferedPsks;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">      <span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">          select (Handshake.msg_type) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">              <span class="keyword">case</span> client_hello: OfferedPsks;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">              <span class="keyword">case</span> server_hello: uint16 selected_identity;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">          &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">      &#125; PreSharedKeyExtension;</span></pre></td></tr></table></figure><ul><li>identity:<br>一个预共享密钥的标签。</li><li>obfuscated_ticket_age:<br>SessionTicket的寿命的混淆版本，为了防止一些相关连接的被动观察者。而在TLS1.2中是不存在这样的字段，即不会标识出客户端已存在的时间，server收到后主要靠里面的内容来判断Ticket是否过期，而在TLS1.3中就增加了这样一个字段来表示Ticket的寿命，因为是明文传输所以会被观察者发现，所以给时间加了一些调味品，是New Session Ticket中的ticket_age_add，因为New Session Ticket本身就是被加密的，所以这个ticket_age_add只有通信两端才知道。</li><li>混淆的方法：<br>用 ticket 时间(毫秒为单位)加上 “ticket_age_add” 字段，最后对 2^32 取模。注意，NewSessionTicket 消息中的 “ticket_lifetime” 字段是秒为单位，但是 “obfuscated_ticket_age” 是毫秒为单位。</li><li>identities:<br>Client 愿意和 Server 协商的 identities 列表，其内容就是NewSessionTicket中的ticket部分。如果和 early_data 一起发送，第一个标识被用来标识 0-RTT 的。有关early_data后面还会说到。</li><li>selected_identity:<br>server选择的标识，是server在自己的 Pre-Shared Key扩展中自己设置的选择的标识，表明正常解析了Client的扩展，其实选择的话就是一个序号。   </li></ul><h4 id="0-RTT"><a href="#0-RTT" class="headerlink" title="0-RTT"></a>0-RTT</h4><p>前面已经提到过TLS1.3已经将握手时间优化到了1-RTT，对比之前版本的速度已经快了很多，但是TLS1.3最终极的做法是0-RTT，即握手的时间是0-RTT。  </p><p>Client发送ClientHello消息，除了在PSK模式中提到的那些扩展外，还应该具有一个early_data扩展，同理server发送serverHello中也应该包括该扩展，并表示其愿意接受early_data，client发送完early_data后，发送End_Of_Early_Data报文表示client自己发送完了early_data。  </p><p>如果 Server 提供了 early_data 扩展，Client 必须验证 Server 的 selected_identity 是否为 0。如果返回任何其他值，Client 必须使用 “illegal_parameter” alert 消息中止握手。下面我们看一下它的结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>&#125; Empty;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        select (Handshake.msg_type) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> new_session_ticket:   uint32 max_early_data_size;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> client_hello:         Empty;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> encrypted_extensions: Empty;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125; EarlyDataIndication;</span></pre></td></tr></table></figure><p>其中的max_early_data_size字段表明，允许Client发送的最大0-RTT的数据量。  </p><p>发生错误会导致0-RTT降级到1-RTT。  </p><h4 id="New-Session-Ticket"><a href="#New-Session-Ticket" class="headerlink" title="New Session Ticket"></a>New Session Ticket</h4><p>Post-Handshake Messages在 Server 接收到 Client 的 Finished 消息以后的任何时刻，它都可以发送 NewSessionTicket 消息。此消息在 ticket 值和从恢复主密钥派生出来的 PSK 之间创建了唯一的关联。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">       uint32 ticket_lifetime;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">       uint32 ticket_age_add;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">       opaque ticket_nonce&lt;<span class="number">0.</span><span class="number">.255</span>&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">       opaque ticket&lt;<span class="number">1.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-1</span>&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">       Extension extensions&lt;<span class="number">0.</span><span class="number">.2</span>^<span class="number">16</span><span class="number">-2</span>&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">   &#125; NewSessionTicket;</span></pre></td></tr></table></figure><ul><li>ticket_lifetime：<br>这个字段表示 ticket 的生存时间，这个时间是以 ticket 发布时间为网络字节顺序的 32 位无符号整数表示以秒为单位的时间。Server 禁止使用任何大于 604800秒(7 天)的值。值为零表示应立即丢弃 ticket。无论 ticket_lifetime 如何，Client 都不得缓存超过 7 天的 ticket，并且可以根据本地策略提前删除 ticket。Server 可以将 ticket 视为有效的时间段短于 ticket_lifetime 中所述的时间段。</li><li>ticket_age_add:<br>安全的生成的随机 32 位值，用于模糊 Client 在 “pre_shared_key” 扩展中包含的 ticket 的时间。Client 的 ticket age 以模 2 ^ 32 的形式添加此值，以计算出 Client 要传输的值。Server 必须为它发出的每个 ticket 生成一个新值。</li><li>ticket_nonce:<br>每一个 ticket 的值，在本次连接中发出的所有的 ticket 中是唯一的。初始值是0，发送一个则++</li><li>ticket:<br>这个值是被用作 PSK 标识的值  </li></ul><h3 id="TLS1-3一些其他扩展和机制"><a href="#TLS1-3一些其他扩展和机制" class="headerlink" title="TLS1.3一些其他扩展和机制"></a>TLS1.3一些其他扩展和机制</h3><h4 id="降级保护机制"><a href="#降级保护机制" class="headerlink" title="降级保护机制"></a>降级保护机制</h4><p>主要通过随机数来实现，当协商TLS1.2或更老的版本，为了响应ClientHello在random后8个字节填入特定的随机值，若为TLS1.2则后8个字节的值为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">44 4F 57 4E 47 52 44 01</span></pre></td></tr></table></figure><h4 id="supported-version"><a href="#supported-version" class="headerlink" title="supported_version"></a>supported_version</h4><p>主要功能的话前面也有提到，对Client标明所支持的TLS版本，对Server标明正在使用的TLS版本，如果协商TLS之前的版本，这个扩展必须带上，若不存在该扩展，server要协商之前的版本，则中止握手，若存在server将禁止使用ClientHello中的legacy_version作为版本协商的值，只能使用supported_versions中的值。<br>对于server：</p><ul><li>版本&lt;TLS1.3 则设置serverHello.version，不能发送supported_version</li><li>版本&gt;=TLS1.3则必须发送supported_version扩展，还要设置serverHello.legacy_version为0x0303，若扩展存在Client会忽略serverHello.legacy_version，而去读取supported_version的值。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">      select (Handshake.msg_type) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">case</span> client_hello:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">               ProtocolVersion versions&lt;<span class="number">2.</span><span class="number">.254</span>&gt;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">case</span> server_hello: <span class="comment">/* and HelloRetryRequest */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">               ProtocolVersion selected_version;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">      &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  &#125; SupportedVersions;</span></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> TLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TLS1.3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyshark解析pcap文件（有关ssh协议握手过程的数据提取）</title>
      <link href="/2020/03/23/pyshark%E8%A7%A3%E6%9E%90pcap%E6%96%87%E4%BB%B6%EF%BC%88%E6%9C%89%E5%85%B3ssh%E5%8D%8F%E8%AE%AE%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96%EF%BC%89/"/>
      <url>/2020/03/23/pyshark%E8%A7%A3%E6%9E%90pcap%E6%96%87%E4%BB%B6%EF%BC%88%E6%9C%89%E5%85%B3ssh%E5%8D%8F%E8%AE%AE%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p> 我需要提取ssh协议握手过程中的数据，找了很多办法，比如是不是可以通过nmap直接提取数据，但是nmap只能提取到服务器使用的算法以及服务器的公钥，所以还需要找其他可行的办法<br> <a id="more"></a></p><h2 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h2><p>知道wireshark的都清楚它的功能，就是截取网络上的数据包，这让我们对互联网有了更加直观的了解，通过截取到的包可以很直观的看到互联网上数据的交互过程。<br>所以我选择使用nmap去访问服务器，然后通过wireshark截取包，再将包导出，wireshark导出的包文件是$.pcap$类型的，网上有很多解析的例子，我也看了很多，比如可以根据该文件类型的结构对其解析，还有可以通过现有的库对其解析：</p><ul><li>$pyshark$</li><li>$scapy$</li><li>$pycapfile$<br>等等。。。。<br>这些工具功能应该都是类似的，大体说一下就是可以发送数据包和接收数据包并保存到本地，可以对数据包进行解析，比如$pyshark$可以解析$.pcap$的数据包，别的不多说了上图：<br><img src="https://img-blog.csdnimg.cn/20200323154336925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这个用法呢就是遍历将文件里面指定的包输出，每个包里面有四个层：$ETH,IP,TCP,SSH$<br>通过：<code>i.ssh</code>就可以访问该层的内容<br><img src="https://img-blog.csdnimg.cn/20200323154650977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></li></ul><hr><p>然后通过特定的函数就可以进行无限的想象和使用举个比较实用的例子：<code>i.ssh.get_field_by_showname(&#39;字段名&#39;)</code>，这样就可以取出ssh层下你想要的数据<br><img src="https://img-blog.csdnimg.cn/20200323155643112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>然后我就这样一步步将所有的想要得到的数据提取了出来，但是还是有些混乱，我猜测看能是多次访问的缘故<br><img src="https://img-blog.csdnimg.cn/20200323155855746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>PyShark入门(4)：packet对象<br><a href="http://zodiacg.net/2016/07/intro2pyshark-ep4/" target="_blank" rel="noopener">http://zodiacg.net/2016/07/intro2pyshark-ep4/</a></p><p>我获得实用工具思路的论坛<br><a href="https://stackoverflow.com/questions/4948043/how-to-parse-packets-in-a-python-library" target="_blank" rel="noopener">https://stackoverflow.com/questions/4948043/how-to-parse-packets-in-a-python-library</a></p><p>官方文档<br><a href="http://kiminewt.github.io/pyshark/" target="_blank" rel="noopener">http://kiminewt.github.io/pyshark/</a></p><p>wireshark知乎大神写的<br><a href="https://zhuanlan.zhihu.com/p/31512066" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31512066</a></p><p>example<br><a href="https://www.programcreek.com/python/example/92562/pyshark.FileCapture" target="_blank" rel="noopener">https://www.programcreek.com/python/example/92562/pyshark.FileCapture</a></p><p>大神写的pcap文件的结构分析<br><a href="https://blog.csdn.net/dog250/article/details/52005893" target="_blank" rel="noopener">https://blog.csdn.net/dog250/article/details/52005893</a></p>]]></content>
      
      
      <categories>
          
          <category> ssh </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pyshark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSH协议握手过程详解</title>
      <link href="/2020/03/20/SSH%E5%8D%8F%E8%AE%AE%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/03/20/SSH%E5%8D%8F%E8%AE%AE%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ssh通过创建安全隧道来实现ssh客户端与服务器之间的连接，<br>它的主要用途是连接远程服务器然后在上面执行指令。<br><a id="more"></a></p><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>ssh协议主要由三部分组成：</p><ul><li>传输层协议：主要负责认证服务器、加密数据、确保数据完整性</li><li>用户身份验证协议：负责认证使用者是否是ssh服务器的用户</li><li>连接协议：将加密的信息通道改成若干个逻辑通道</li></ul><h2 id="传输层协议"><a href="#传输层协议" class="headerlink" title="传输层协议"></a>传输层协议</h2><p>今天主要讲一下传输层协议。</p><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>sever收到来自client发送过来的请求后，先进行三次握手，建立tcp连接，下面给出我使用wireshark抓到的包<br><img src="https://img-blog.csdnimg.cn/20200321115848326.png" alt="tcp"></p><h3 id="算法协商、版本协商"><a href="#算法协商、版本协商" class="headerlink" title="算法协商、版本协商"></a>算法协商、版本协商</h3><p>双方发送自己所支持的版本号以及算法，协商确定版本及算法，若成功则继续，否则断开连接<br><img src="https://img-blog.csdnimg.cn/20200321120339156.png" alt="init"><br><img src="https://img-blog.csdnimg.cn/20200321120755201.png" alt="版本"><br><img src="https://img-blog.csdnimg.cn/20200321121003478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200321121021869.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="密钥交换"><a href="#密钥交换" class="headerlink" title="密钥交换"></a>密钥交换</h3><p>client根据server发送过来的数据生成一对密钥，将公钥发送给server<br><img src="https://img-blog.csdnimg.cn/20200321121448908.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020032112150720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中有一个e字段，这个就是client所生成的公钥<br>server也会生成一对密钥，并且将自己的公钥与client发送过来的公钥一起生成共享密钥，并且会将自己的临时公钥以及host-key，还有server会收集双方的临时公钥、共享密钥、host-key再加上一定的数据例如：server和client的版本字符串，对这些数据使用之前它们协商好的哈希算法计算其哈希值，然后使用自己的私钥对其签名生成signature，然后将这些值一起发送给client<br><img src="https://img-blog.csdnimg.cn/20200321122304654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>client收到后会通过host-key先验证服务器的身份，然后将其保存到本地文件夹中，再使用server发送过来的临时公钥生成共享密钥，再加密签名，将其结果与自己所计算的哈希值进行比较，验证数据时没有问题的，这样的话整个密钥协商环节就结束了。</p><p>一旦建立了加密传输层并且验证了server的身份，client就必须进行身份验证，主要有两种方式：</p><ul><li>密码身份验证：主要就是加密密码进行传输</li><li>密钥对认证：客户端生成密钥对然后将公钥发送给server，server将其存储起来并生成对应的id，将id返回给client，之后client则可以通过id进行验证server是否存在自己的公钥，进而验证身份。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我通过wireshark可以很好的看到密钥协商具体过程的数据，让我更好的去理解这个过程，但是我的目的是去提取过程中的数据，到目前还没有找到相应的解决办法。</p>]]></content>
      
      
      <categories>
          
          <category> ssh </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析比特币区块.dat文件，获得签名r以及其相关信息，并找出相同的r及恢复私钥</title>
      <link href="/2020/03/14/%E8%A7%A3%E6%9E%90%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97.dat%E6%96%87%E4%BB%B6%EF%BC%8C%E8%8E%B7%E5%BE%97%E7%AD%BE%E5%90%8Dr%E4%BB%A5%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%B9%B6%E6%89%BE%E5%87%BA%E7%9B%B8%E5%90%8C%E7%9A%84r%E5%8F%8A%E6%81%A2%E5%A4%8D%E7%A7%81%E9%92%A5/"/>
      <url>/2020/03/14/%E8%A7%A3%E6%9E%90%E6%AF%94%E7%89%B9%E5%B8%81%E5%8C%BA%E5%9D%97.dat%E6%96%87%E4%BB%B6%EF%BC%8C%E8%8E%B7%E5%BE%97%E7%AD%BE%E5%90%8Dr%E4%BB%A5%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%B9%B6%E6%89%BE%E5%87%BA%E7%9B%B8%E5%90%8C%E7%9A%84r%E5%8F%8A%E6%81%A2%E5%A4%8D%E7%A7%81%E9%92%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>先在前面说一下，我没有完全实现整个过程，因为有一个地方确实实现不了，等以后有条件再使用别的方法尝试一下。前一段时间看了一篇14年的论文，里面主要说的是比特币中随机数相同会造成私钥泄漏的问题，作者分析了当下存在很多因私钥泄漏，比特币频频被盗的现象，然后找到了问题所在，并且使用<a href="https://github.com/FiloSottile/blockchainr" target="_blank" rel="noopener">Blockchainr</a>工具将其实现了，找出了比特币网络中存在的使用相同随机数的用户私钥。</p><a id="more"></a><h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>处于自身学习的角度，我要自己完成作者所提到的步骤，最终找到相同的随机数并且恢复私钥。</p><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><p>先编写解析区块文件的程序，将后缀为.dat的区块文件解析出来，然后将数据存储到数据库，之后再借助14年那篇PPT的思想，利用作者提到的dabloom过滤器去找到相同的签名r，这时我们不能仅仅导出签名r，还要导出相关的信息，这样我们才可以知道是否来源于同一用户，才能去计算用户私钥。</p><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><p>目前我可以实现解析区块并导出到数据库中，把.dat文件以二进制形式读取，编写区块结构并给出区块中各个字段的长度，以及通过已知字段的值，去读取某些未知长度字段的数据，如：解锁脚本可以通过脚本长度来读取，还有我们可以通过下图这样的思想去解析区块：<br><img src="https://img-blog.csdnimg.cn/20200314175843672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="idear"><br>从block入手，里面包含blockheader、tx因为一个区块有多条交易，我们定义tx为一个集合Txs，Txs中的每条交易又包含input、output当然它们也会存在多条，所以依然定义为集合，这样我们就可以通过遍历的方式将一个区块的所有数据导出。下面给出部分代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,blockchain)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        self.blockheight = <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        self.continueParsing = <span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        self.magicNum = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        self.blocksize = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        self.blockheader = <span class="string">''</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        self.txCount = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        self.Txs = []</span></pre></td></tr></table></figure><p>这样的话从block入手，就可以逐层解码文件，最终得到完整的区块信息。</p><h3 id="ScriptSig"><a href="#ScriptSig" class="headerlink" title="ScriptSig"></a>ScriptSig</h3><p>因为我们要找到签名$r$，所以必须要解析签名脚本，我主要是通过解码$16$进制的字符串得到的，做之前我们要清楚解锁脚本的结构，这样才能正确处理，下面给出一张解锁脚本的结构图：<br><img src="https://img-blog.csdnimg.cn/20200117232230699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="ScriptSig"><br>知道这些的话我们就可以通过脚本长度，签名长度等来进一步分割字符串，并且给出判定条件当前置交易索引不为$0xffffffff$时解析scriptsig，因为相等时交易时coinbase交易，是系统给的交易而不是经过人签名得来的，所以不具备$ECDSA$签名脚本，详情可以看我的另外一篇博客：<a href="https://blog.csdn.net/qq_35324057/article/details/104072715" target="_blank" rel="noopener">https://blog.csdn.net/qq_35324057/article/details/104072715</a><br>下面给出实现这部分的代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">0xffffffff</span> != self.txpreindex:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">         scriptsig = ScriptSig(self.inscriptsig)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">         self.sigr = scriptsig.sigR</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">         self.sigs = scriptsig.sigS</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">         self.inpubkey = scriptsig.pubkey</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">         self.sigr = <span class="string">''</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">         self.sigs = <span class="string">''</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">         self.inpubkey = <span class="string">''</span></span></pre></td></tr></table></figure><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScriptSig</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,blockchain)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># if blockchain[8:10] == '20':</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">#         #     self.sigR = blockchain[10:74]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">#         #     if blockchain[76:78] == '20':</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">#         #         self.sigS = blockchain[78:142]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">#         #     else:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">#         #         self.sigS = blockchain[78:144]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">#         # else :</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">#         #     self.sigR = blockchain[10:76]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">#         #     if blockchain[78:80] == '20':</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">#         #         self.sigS = blockchain[78:142]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">#         #     else:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">#         #         self.sigS = blockchain[78:144]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        self.scriptLength = int(blockchain[<span class="number">0</span>:<span class="number">2</span>],<span class="number">16</span>)*<span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        self.script = blockchain[<span class="number">2</span>:<span class="number">2</span> + self.scriptLength]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        self.rLength = int(blockchain[<span class="number">8</span>:<span class="number">10</span>],<span class="number">16</span>)*<span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        self.sigR = blockchain[<span class="number">10</span>:<span class="number">10</span>+self.rLength]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        self.sLength = int(blockchain[<span class="number">10</span>+self.rLength+<span class="number">2</span>:<span class="number">10</span>+self.rLength+<span class="number">2</span>+<span class="number">2</span>],<span class="number">16</span>)*<span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        self.sigS = blockchain[<span class="number">10</span>+self.rLength+<span class="number">2</span>+<span class="number">2</span>:<span class="number">10</span>+self.rLength+<span class="number">2</span>+<span class="number">2</span>+self.sLength]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> SIGHASH_ALL != int(blockchain[self.scriptLength:self.scriptLength + <span class="number">2</span>], <span class="number">16</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            self.pubkey = <span class="string">"Script op_code is not SIGHASH_ALL"</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            self.pubkey = blockchain[<span class="number">2</span> + self.scriptLength + <span class="number">2</span>:<span class="number">2</span> + self.scriptLength + <span class="number">2</span> + <span class="number">66</span>]</span></pre></td></tr></table></figure><p>这样就得到了计算私钥需要使用的两个值：$sigR,sigS$，但是我们还需要得到交易的哈希值$Z$，这一点真的太难了，为什么这么说呢，因为交易的哈希值并不是简单的对区块中的某个值做哈希运算，而是需要找到该交易的$prehash$所指向的交易，为什么要这样做呢，不知道的小伙伴请看我的上面提到的那篇博客，我们要是用前驱交易的交易输出部分，或者称为加密脚本，并且还需要一些删减增加字符串，然后最终得到我们的交易字符串，对其进行两次$sha256$运算得到$Z$，这一点是无法实现的。有时间的话我会单独写一篇关于计算交易哈希值的文章。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>对于redis是什么我就不多说了，就是一种key-value的数据库。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul><li>pycharm安装redis包：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">pip install redis</span></pre></td></tr></table></figure><ul><li>然后再下载安装redis数据库<br><img src="https://img-blog.csdnimg.cn/20200315193044498.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="redis"></li><li>安装RedisDesktopManager ———-redis数据库的可视化工具</li></ul><h4 id="插入区块数据"><a href="#插入区块数据" class="headerlink" title="插入区块数据"></a>插入区块数据</h4><p>这也是我实现的最大的难点，主要就是如果key相同的话，因为每个区块都有相同的字段，所以key的值就会被覆盖，如果一个.dat文件中有多个区块的话，到最后插入的数据也只是最后一个区块的数据，而不能将所有的区块数据插入，实现这一点浪费了我极大的时间和经历，希望分享出来能帮到大家！</p><h5 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h5><p>主要的思想就是用不同的key来标识不同区块不同tx不同input中的数据。<br>如：我们用$previousHash+$字段名，来标识不同区块的数据，用$previousHash+Txseq+$字段名，来标识一个区块中不同的tx中的数据，依次类推，可以得到插入所有数据的方法，下面给出一些代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#insert into redis DB</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">#blockheader</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + 'Version',self.version)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + 'PreviousHash', self.previoushash)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + 'MerkleRoot', self.Hash)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + 'Timestamp', self.time)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + 'Difficulty', self.difficulty)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + 'Nonce', self.nonce)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">#</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># # block</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + 'MagicNum', self.magicnum)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + 'Blocksize', self.blocksize)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + 'Txcount', self.txcount)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">#</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># # Tx</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + self.txseq + 'TxVersion', self.txversion)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + self.txseq + 'InCount', self.incount)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + self.txseq + 'Txseq', self.txseq)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + self.txseq + 'OutCount', self.outcount)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + self.txseq + 'LockTime', self.locktime)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">#</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># # Input</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + self.txseq + self.inputseq + 'TxPrevHash', self.txprevhash)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + self.txseq + self.inputseq + 'TxPreIndex', self.txpreindex)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + self.txseq + self.inputseq + 'InScriptLen', self.inscriptlen)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + self.txseq + self.inputseq + 'InScriptSig', self.inscriptsig)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># re.set(self.previoushash + self.txseq + self.inputseq + 'InSequence', self.sequence)</span></span></pre></td></tr></table></figure><h4 id="取数据"><a href="#取数据" class="headerlink" title="取数据"></a>取数据</h4><p>如果往里面存数据理解的话，取数据也很好理解了，主要就是利用了区块中本来就存在几个数据，$txcount$、$inputcount$、$outputcount$，利用这几个数据的话，就可以遍历它们得到数据，很简单就可以实现，如：$get(previousHash+i+’txversion’)$，其中$i$就是从0遍历到$txcount$，前面还有个东西忘了说，你查询数据用到的数据一定要存储起来，比如$previousHash$，就需要按序号存储起来，并且字段名方便提取，这样的话，提取数据的时候，用起来才会很方便。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">19972</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">        hash = re.get(<span class="string">'Hash'</span> + str(i))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        txcount = re.get(hash + <span class="string">'Txcount'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># print(txcount)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,int(txcount)):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="comment"># print ("Locktime:%s" % re.get(hash + str(j) + 'InCount'))</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">            incount = re.get(hash + str(j) + <span class="string">'InCount'</span>)</span></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还有一些地方没有说，就不写了，总之这个过程还是很有收获的，就是在做的过程中很难过，每天需要有点进度，我却卡在数据库上面很长时间，希望大家每天也能有所收获，无论希望多渺茫，都要继续加油！</p>]]></content>
      
      
      <categories>
          
          <category> Bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 解析区块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSL_TLS握手</title>
      <link href="/2020/02/28/SSL_TLS%E6%8F%A1%E6%89%8B/"/>
      <url>/2020/02/28/SSL_TLS%E6%8F%A1%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>最近在看一篇论文，<a href="https://eprint.iacr.org/2013/734.pd" target="_blank" rel="noopener">Elliptic Curve Cryptography in Practicef</a>里面联系到TLS协议的各方面东西，所以去了解了一下SSL\TLS协议握手时候的大概流程，现在把它记录下来。<br><a id="more"></a></p><h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h2><p>首先简单说一下什么是证书，为了证实服务器的身份，并确保他不是攻击者，证书是由第三方可信机构颁发的，我们称之为：CA，CA用其私钥对证书签名，这样用户可以对服务器发送过来的证书进行验证。证书中包含服务器的公钥，可信第三方的签名等东西</p><h2 id="握手的大概过程"><a href="#握手的大概过程" class="headerlink" title="握手的大概过程"></a>握手的大概过程</h2><p>客户端发送许多规范为了知道服务器使用的规范：</p><ul><li>服务器正在运行的哪个版本的SSL/TLS</li><li>服务器使用的是什么密码套件</li><li>服务器使用什么压缩方法<br>通过OpenSSL操作的话一般使用如下命令例：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">openssl s_client -<span class="built_in">connect</span> the.host.name:<span class="number">443</span></span></pre></td></tr></table></figure><p>当然里面还可以添加很多东西，有空再整理吧！<br>这样的话服务器收到客户端发送的<code>s_client</code>后从中选择一个支持的密码套件并选择一个压缩方法，之后向客户端发送它的证书，客户端验证证书并确定此服务器确实是他声称身份而非中间人，之后交换秘钥。从现在开始，所有通信将会被加密，并将加密且经过身份验证的消息发送到服务器，服务器验证身份正确并且消息可以正确解密，然后它返回一条消息客户端也将对其进行验证至此握手已经完成。</p><h2 id="与论文中内容的联系"><a href="#与论文中内容的联系" class="headerlink" title="与论文中内容的联系"></a>与论文中内容的联系</h2><p>作者在TLS部分，测试服务器所使用的密码套件以及椭圆曲线的时候，若服务器接收则将其密码套件及曲线从列表中移除（因为作者只做与椭圆曲线有关的实验，所以里面只包含与椭圆曲线有关的密码套件及曲线），然后作者采用<code>Event-driven</code>程序，再次发送消息，直到不能连接，即列表为空或者列表中的密码套件及曲线已经不能支持服务器，这时将不能得到有效反馈，至此作者通过这种方法测试出了服务器所使用的所有密码套件以及曲线。</p><h2 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h2><p>ECDH：秘钥交换协议</p><h3 id="ECDH与ECDHE的区别"><a href="#ECDH与ECDHE的区别" class="headerlink" title="ECDH与ECDHE的区别"></a>ECDH与ECDHE的区别</h3><ul><li>ECDHE是E = Ephemeral版本，您在<br>每次握手时都会获得不同的DH密钥 。</li><li>ECDH具有固定的DH密钥；握手的一侧不会从<br>一个实例更改为 另一个实例。</li><li>ECDHE为您提供保密性；ECDH没有。</li><li>ECDHE比ECDH效率低；它需要更多的加密操作。</li><li>它们在握手验证方式上也有所不同。（ECDH是<br>隐式的，而ECDHE是显式的。）</li></ul><h2 id="pS"><a href="#pS" class="headerlink" title="pS"></a>pS</h2><p>明天搞一下详解</p>]]></content>
      
      
      <categories>
          
          <category> 握手 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TLS/SSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Nmap获取SSH、SSL_TLS中公钥、cipersutes、签名等相关数据</title>
      <link href="/2020/02/26/%E4%BD%BF%E7%94%A8Nmap%E8%8E%B7%E5%8F%96SSH%E3%80%81SSL_TLS%E4%B8%AD%E5%85%AC%E9%92%A5%E3%80%81cipersutes%E3%80%81%E7%AD%BE%E5%90%8D%E7%AD%89%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE/"/>
      <url>/2020/02/26/%E4%BD%BF%E7%94%A8Nmap%E8%8E%B7%E5%8F%96SSH%E3%80%81SSL_TLS%E4%B8%AD%E5%85%AC%E9%92%A5%E3%80%81cipersutes%E3%80%81%E7%AD%BE%E5%90%8D%E7%AD%89%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Nmap工具"><a href="#Nmap工具" class="headerlink" title="Nmap工具"></a>Nmap工具</h2><h3 id="相关脚本"><a href="#相关脚本" class="headerlink" title="相关脚本"></a>相关脚本</h3><p><a href="https://svn.nmap.org/nmap/scripts/ssh-hostkey.nse" target="_blank" rel="noopener">ssh-hostkey</a>显示SSH主机的公钥<br><a href="https://svn.nmap.org/nmap/scripts/ssl-enum-ciphers.nse" target="_blank" rel="noopener">ssl-enum-ciphers</a>该脚本重复启动SSLv3 / TLS连接，每次在记录主机是否接受时都尝试使用新的密码或压缩程序。最终结果是服务器接受的所有密码套件和压缩器的列表，主要就是返回的主机所使用的密码套件和椭圆曲线。<br><a href="https://svn.nmap.org/nmap/scripts/ssl-cert.nse" target="_blank" rel="noopener">ssl-cert</a>检索服务器的SSL证书。我主要通过这个脚本获得了以MD5和sha-1输出的签名，但是我还没搞懂对谁签的名。<br><a id="more"></a></p><h4 id="用法示例"><a href="#用法示例" class="headerlink" title="用法示例"></a>用法示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">nmap host --script ssh-hostkey --script-args ssh_hostkey=sha256</span></pre></td></tr></table></figure><p>返回的是以sha256形式输出的Hostkey，示例如下图：<br><img src="https://img-blog.csdnimg.cn/20200226195740230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="hostkey"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">nmap -sV --script ssl-<span class="keyword">enum</span>-ciphers -p <span class="number">443</span> &lt;主机&gt;</span></pre></td></tr></table></figure><p>下面展示一下示例图：<br><img src="https://img-blog.csdnimg.cn/202002262010499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="ciper"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">nmap -p443 --script ssl-cert &lt;主机&gt;</span></pre></td></tr></table></figure><p>下面给出示例图：<br><img src="https://img-blog.csdnimg.cn/2020022620205383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="cert"></p><h3 id="注"><a href="#注" class="headerlink" title="注"></a>注</h3><ul><li>ssh协议对应的端口号是：22</li><li>TLS\SSL对应的端口号是：443，使用的协议是：https</li><li>还有导出到文件的代码：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">nmap --script ssl-<span class="keyword">enum</span>-ciphers -p <span class="number">443</span> -iL 使用的文件名加后缀 -oN 导出的文件名加后缀</span></pre></td></tr></table></figure><h3 id="nmap的安装来源"><a href="#nmap的安装来源" class="headerlink" title="nmap的安装来源"></a>nmap的安装来源</h3><p><a href="https://nmap.org/download.html" target="_blank" rel="noopener">nmap</a>直接安装就可以，同时也支持window系统</p>]]></content>
      
      
      <categories>
          
          <category> Nmap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Private Key Recovery Combination Attacks2</title>
      <link href="/2020/02/18/Private%20Key%20Recovery%20Combination%20Attacks2/"/>
      <url>/2020/02/18/Private%20Key%20Recovery%20Combination%20Attacks2/</url>
      
        <content type="html"><![CDATA[<h2 id="Solution——BIP032"><a href="#Solution——BIP032" class="headerlink" title="Solution——BIP032"></a>Solution——BIP032</h2><p><img src="https://img-blog.csdnimg.cn/20200218165329379.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="fig1"><br>当$i\geq2^{31}$时，我们称之为硬化子秘钥衍生，如下图：<br><a id="more"></a><br><img src="https://img-blog.csdnimg.cn/20200218171812998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="fig2"><br>对于solution1，如果我们知道扩展私钥$k_1$，并且知道该私钥的相对位置，那么我们可以通过$K,xc$(链码)计算得到$y_1、y_2$，由于：$y_1<em>k \, mod \, q=k_1$，所以我们可以解出$k$，进而可以计算出：$y_2</em>k\, mod \,q=y_2$，依次类推进而计算出所有的私钥。同理可证solution2。</p><h2 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h2><p>如果攻击者知道$Extended\:Public\:Key\:K||xc$并且相同的随机数被处在同一层中的两个用户使用了，知道他们的相对路径，那么可以计算出对应的：$y_L$，我们假设用户1对应的是：$y_1$，用户2对应的是：$y_2$所以两个对应的私钥就是：$ky_1、ky_2$，得到：<br>$as_1=(H(m1)+rky_1)\,mod\,q$<br>$as_2=(H(m2)+rky_2)\,mod\,q$<br>将第一个等式中的$a$表示出来带入第二个等式得到：<br>$k=\frac{H(m2)s_1-H(m1)s_2}{ry_1s_2-ry_2s_1}mod\:q$<br>这样我们就可以解得私钥的值。</p><hr><p>如果攻击者知道两个不同层次的：$K,xc$以及用户的相对位置，并且随机数$a、b$都各自使用了一次，一共有四个用户。<br>对于solution1因为我们知道用户的相对位置，我们可以计算出：$ky_1，k’y_2，ky_3，k’y_4$并且得到如下几个式子：</p><p>$as_1=(H(m1)+r_aky_1)\,mod\,q$<br>$as_2=(H(m2)+r_ak’y_2)\,mod\,q$<br>$bs_3=(H(m3)+r_bky_3)\,mod\,q$<br>$bs_4=(H(m4)+r_bky’_1)\,mod\,q$<br>$ky_1s_2-k’y_2s_2=\frac{H(m_2)s_1+H(m1)s_2}{r_a}mod\,q$<br>$ky_3s_4-k’y_4s_3=\frac{H(m_4)s_3+H(m3)s_4}{r_b}mod\,q$<br>两个方程可以解出$k$和$k’$，与之前类似的方法即可解出所有私钥。solution2同理。</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HD钱包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Private Key Recovery Combination Attacks1</title>
      <link href="/2020/02/18/Private%20Key%20Recovery%20Combination%20Attacks/"/>
      <url>/2020/02/18/Private%20Key%20Recovery%20Combination%20Attacks/</url>
      
        <content type="html"><![CDATA[<h2 id="Bitcoin-and-Key-Management"><a href="#Bitcoin-and-Key-Management" class="headerlink" title="Bitcoin and Key Management"></a>Bitcoin and Key Management</h2><p>比特币提供了匿名性，但是匿名性很差，使用多个私钥会获得较好的匿名性。但是如果比特币钱包包含的是随机生成的私钥，将会产生大量的私钥，在实际中很难管理，并且占用大量储存空间。所以找到一个好的解决方法至关重要。在较早的一批比特币客户端中，使用的是随机生成私钥的集合的钱包，这种钱包被称为零型非确定型钱包，它的缺点就是如果你生成很多私钥，就必须要保存它们的副本，不然私钥丢失里面的比特币也将付诸东流，并且这种情况与避免重复使用地址相冲突，地址关联多重交易和对方地址重复使用会减少隐私，也就是降低匿名性，所以这种钱包不是一种很好的选择，下面为大家介绍解决方法——确定性钱包<br><a id="more"></a></p><h2 id="确定性的私钥管理"><a href="#确定性的私钥管理" class="headerlink" title="确定性的私钥管理"></a>确定性的私钥管理</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>限制了私钥的公开程度，并且限制了攻击者可以针对传统算法攻击和旁路攻击进行处理</li><li>大大节省了存储空间</li></ul><h3 id="Type1"><a href="#Type1" class="headerlink" title="Type1"></a>Type1</h3><p><img src="https://img-blog.csdnimg.cn/20200217172210850.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="fig1"><br>通过对种子和索引$n$哈希生成索引所对应的私钥。我们可以利用种子来将所有的私钥恢复，所以在备份的时候只需要备份种子就可以了。这样的话极大减少了备份私钥的空间，并且有利于钱包的管理，但是也有致命性的缺点如果种子被盗取，那么将造成钱包中所有私钥的泄漏！！！<br>我们的目标是希望能够生成用于接收大量不同交易的比特币唯一私钥，这将增加交易的匿名性。<br>这种类型我们还以用作种子生成主私钥，然后主私钥生成子私钥，以此类推，子私钥可以生成孙私钥，这样的话就可以得到无穷无尽并且很方便管理的私钥群。并且不同的分支用作不同的用途，将更加方便我们的生活。</p><hr><h3 id="Type2"><a href="#Type2" class="headerlink" title="Type2"></a>Type2</h3><p><img src="https://img-blog.csdnimg.cn/20200217174118175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="fig2"><br>我们希望有2个推导函数。例如，无论是通过Public派生函数计算还是从SK3计算得出，PK3都应该相同，并且公共种子不应泄露私有种子或任何私有密钥，所有的推导函数都由单向函数来完成。</p><hr><p>除了公钥、私钥外，它们还有其它的链值，如下图，因此，知道ECDSA的私钥也不能解出其它的私钥，但是如果seed遭到泄漏之后，那么会造成所有私钥的泄漏，造成严重的后果。并且允许为单个交易生成单个私钥。<br><img src="https://img-blog.csdnimg.cn/20200217175920356.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="fig3"></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>我们将扩展私钥定义为：$Extended Private Key=(private key +xc)$<br>扩展公钥是：$Extended Public Key=(Extended Private Key+xc)$<br>定义$N$为扩展私钥转换成扩展公钥的操作，所以我们有：<br>$N (k||xc) = (k.G||xc)$</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p><img src="https://img-blog.csdnimg.cn/20200217182307317.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="fig4"><br>其中HM是HMAC，利用哈希算法，以一个秘钥和一个消息为输入生成一个消息摘要作为输出。<br>前面的公式：$N(k||xc)=(K||xc)$，可以转换成：$N(k_i,c_i)=(K_i,c_i)$<br>具体过程：$k_i.G=(y_{l_i}*k_L).G=y_{l_i}.(k_L.G)=y_{l_i}.K_L=K_i$ 所以可以得到上面的结果，其中定向的路径都可以生成完全相同的公钥</p><hr><p><img src="https://img-blog.csdnimg.cn/20200217183527914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="fig5"><br>其中的具体过程：$k_i.G=(y_{L_i}+k_L).G=y_{L_i}.G+k_L.G=y_{L_i}.G+K_L=K_i$<br>即可以得到：$N(k_i,c_i)=(K_i,c_i)$</p><hr><h2 id="HD钱包"><a href="#HD钱包" class="headerlink" title="HD钱包"></a>HD钱包</h2><p><img src="https://img-blog.csdnimg.cn/20200218135414557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="fig6"><br>分层确定性钱包使用CKD（child key derivation)方程去从母密钥衍生出子密钥。<br>子秘钥的衍生方程式基于单向哈希方程，主要有以下几部分组成：</p><ul><li>一个母私钥</li><li>一个叫做链码的种子</li><li>一个索引号<br>所以只有私钥和索引并不能衍生出所有的私钥，还需要链码。<br><img src="https://img-blog.csdnimg.cn/20200218140200595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="fig7"></li></ul><h3 id="扩展密钥-BIP32"><a href="#扩展密钥-BIP32" class="headerlink" title="扩展密钥(BIP32)"></a>扩展密钥(BIP32)</h3><p>为了防止密钥衍生仅依赖于自身，协议中引入了一个256位的熵，称为链码。$key||chain_{code}$<br>衍生：$(key_{child},chain_{codechild})=CKD((key_{parent},chain_{codeparent}),index)$ 这是扩展私钥的衍生过程对应于上图中的数据。扩展公钥的衍生过程与其同理。<br>普通衍生的索引范围是：$0-(2^{31}-1)$<br>如果子私钥泄漏，且扩展公钥中含有链码，所以攻击者就可以利用私钥+链码衍生出所有的后续私钥，同时可以利用链码和子私钥猜测母私钥。所以又出现了“硬化子秘钥的衍生”</p><h3 id="硬化子秘钥的衍生"><a href="#硬化子秘钥的衍生" class="headerlink" title="硬化子秘钥的衍生"></a>硬化子秘钥的衍生</h3><p>它是利用母私钥直接去计算子链码，而不是利用母公钥，这样就使得链码不会暴露，所以也就无法利用私钥去进一步衍生其他私钥。<br><img src="https://img-blog.csdnimg.cn/20200218142452868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="fig8"><br>硬化衍生索引的范围是：$2^{31}-2^{32}$</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>公式：母私钥生成子私钥<br>$key_i,chain_{code_i}=CKD((key_{parent},chain_{code_{parent}}),i)$</p><ul><li>如果$i \geq2^{31}$，要进行硬化衍生，获得新序列：<br>$I=HMAC-SHA512(key=chain_{code_{parent}},data=0x00||ser_{256}(key_{parent})||ser_{32}(i))$</li><li>如果$i\leq2^{31}$，则要进行普通衍生获得新序列：<br>$I=HMAC-SHA512(key=chain_{code_{parent}},data=ser_p(point(key_{parent}))||ser_{32}(i))$</li><li>最后将$I$分为两部分$(I_L,I_R)=I$<br>$I_R$即为子密钥的$chain_{code}$<br>$I_L$和母私钥及索引可以推算出子私钥</li></ul>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HD钱包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Speed Optimizations in Bitcoin Key Recovery Attacks</title>
      <link href="/2020/02/15/Speed%20Optimizations%20in%20Bitcoin%20Key%20Recovery%20Attacks/"/>
      <url>/2020/02/15/Speed%20Optimizations%20in%20Bitcoin%20Key%20Recovery%20Attacks/</url>
      
        <content type="html"><![CDATA[<h2 id="Fixed-Point-Multiplication-Methods"><a href="#Fixed-Point-Multiplication-Methods" class="headerlink" title="Fixed Point Multiplication Methods"></a>Fixed Point Multiplication Methods</h2><h3 id="double-and-add"><a href="#double-and-add" class="headerlink" title="double-and-add"></a>double-and-add</h3><p>在椭圆曲线中计算：$Q=kP$比较容易想到的方法是：double-and-add方法。此方法的想法是将$k$采用二进制表示：<br>&ensp;&ensp;&ensp;&ensp;&ensp; $k=k_0+2k_1+2^2k_2+\cdots+2^mk_m$<br>其中的 $[k_0,\cdots,k_m]\epsilon[0,1]$，并且 $m$ 是 $k$ 的位长度，所以在Bitcoin中 $m=256$。<br>给出其算法：<br><a id="more"></a><br><img src="https://img-blog.csdnimg.cn/2020021516255094.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="double-and-add"><br>如果直接计算 $Q=kP$，那我们要计算 $k$ 次点加运算，如果我们设运行一次点加运算的时间为：$A$，那么总的时间是：$kA$。<br>在上面的算法中，$k_i=1$ 的可能大约是 $\frac{m}{2}$，我们假设计算一次倍加所需的时间是：$D$，所以总的运行时间是：$(\frac{m}{2})A+mD$，显然要比之前的运行时间缩短了很多。</p><hr><p>因为$P$是固定不变的，所以我们可以通过预先计算一些依赖于$P$的数据来加速点乘法的操作。例如我们可以预先计算：<br>&ensp;&ensp;&ensp;&ensp;&ensp;$2P,2^2P,\cdots,2^{m-1}P$<br>这样的话在上述算法中$P:=2P$就无需计算了，也就是说只剩了点加运算，我们再分析一些计算时间的话，现在只有：$(\frac{m}{2})A$，很明显又极大的缩短了计算时间。下面我们具体说明这种算法。</p><hr><h3 id="固定基窗口算法"><a href="#固定基窗口算法" class="headerlink" title="固定基窗口算法"></a>固定基窗口算法</h3><p>它的主要特点是先计算预置表，再进行主程序的运算，以使得主程序不需要倍点运算。<br>假定$(K_{d-1},\cdots,K_1,K_0)_2^w$是以$k$的以$2^w$为基的表达式，其中$d=[\frac{m}{w}]$，令$Q_j=\sum_{i:K_i=j}2^{wi}P$，对于$1\leq j\leq2^w-1$有：<br>&ensp;&ensp;&ensp;&ensp;&ensp;$kP=\sum_{i=0}^{d-1}K_i2^{wi}P=\sum_{j=1}^{2^w-1}(j\sum_{i:K_i=j}2^{wi}P)=\sum_{j=1}^{2^w-1}jQ_j=<br>Q_{2^w-1}+(Q_{2^w-1}+Q_{2^w-2})+\cdots+(Q_{2^w-1}+Q_{2^w-2}+\cdots+Q_1)$<br>在计算$kP$的过程中，仅需计算$Q_j$，然后通过$Q_j$相加即可得出$kP$，而$Q_j$是预置表中的点，且其值为已知，因此通过查询预置表并结合点加运算就可以得到$kP$，从而省略了倍点运算，在忽略预置表的计算时间的情况下，我们可以分析其运行时间，3.1步点加需要的运行时间：$(d-1)A$，3.2步点加所需要的运行时间：$(2^w-1-1)A$，所以中总的运行时间为：$(2^w+d-3)A$<br><img src="https://img-blog.csdnimg.cn/20200215172517981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="固定基窗口算法"><br>作者通过查阅之前的类似算法发现，这些算法对内存的消耗十分友好，但是作者要追求的是缩短运行时间，耗费多点内存无可厚非，所以作者从这个方向出发提出了一种新的计算方法，此方法将会占用更多的内存资源，也就是在预计算中消耗的。</p><hr><h3 id="新方法"><a href="#新方法" class="headerlink" title="新方法"></a>新方法</h3><p>作者提出$P_j=jP$，在这里$1\leq j\leq2^w-1$，对于每一个$P_j$计算$P_{i,j}=2^{wi}Pj$，整体的算法和固定窗口基算法一样，作者只是将其中一大部分提前计算了出来，虽然会占用较大的内存，但是会极大的提升计算速度。<br><img src="https://img-blog.csdnimg.cn/20200215173744742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="New method"><br>我们可以发现如果忽略预计算的时间，则需要运行的时间大概是$(d-1)A$，与前面固定基窗口算法相比，可以看出明显提升了计算速度。</p><hr><p>下面给出在不同的窗口宽度w下的测试结果：<br><img src="https://img-blog.csdnimg.cn/2020021517422387.png" alt="result"><br>我们可以发现在$w=20$的情况下效果最好！</p>]]></content>
      
      
      <categories>
          
          <category> 论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 椭圆曲线 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BrainWallet背景故事</title>
      <link href="/2020/02/13/BrainWallets%E8%83%8C%E6%99%AF%E6%95%85%E4%BA%8B/"/>
      <url>/2020/02/13/BrainWallets%E8%83%8C%E6%99%AF%E6%95%85%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>比特币钱包的主要功能时存储地址和其对应的私钥，它有多种不同的形式，包括桌面软件、移动App，在线服务、硬件、智能卡和纸钱包等，而私钥呢是一个完全随机的数字，一般是256位二进制数，以64位16进制数显示，这对于人脑而言是很难记忆的并且做到安全存储，无论你使用哪种钱包，都始终有可能因网络安全漏洞而丢失私钥。<br>而大脑钱包就是一种解决方案，不需要用户将任何东西放在安全的地方并且仍然能够恢复其私钥，无需存储和保护私钥，而是可以将其存储在人的脑海当中，其使用人工选择的密码或密码短语创建私钥，使用SHA256算法，将其转换成256位二进制数，由于SHA256算法是确定性的方法，用户始终可以使用相同的密码来重新创建私钥，而不需要记住私钥，所以脑钱包的安全性仅取决于密码的不可预测性。</p><h3 id="提出时间"><a href="#提出时间" class="headerlink" title="提出时间"></a>提出时间</h3><p>2012年4月，一个名叫BrainWallet.org的网站出现了，这是一个基于网页的JavaScript比特币地址生成器</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>由于密码产生私钥，所以攻击者只要猜出密码就可以得到私钥并立即盗窃用户的BTC，并且攻击者可以无节制的进行离线猜测候选密码，因为在比特币区块链上，所有交易都是公开透明的，因此攻击者可以提取出所有的地址与自己所猜测的地址进行匹配</p>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BrainWallets </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有关Bitcoin的椭圆曲线-secp256k1</title>
      <link href="/2020/02/11/%E6%9C%89%E5%85%B3Bitcoin%E7%9A%84%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF-secp256k1/"/>
      <url>/2020/02/11/%E6%9C%89%E5%85%B3Bitcoin%E7%9A%84%E6%A4%AD%E5%9C%86%E6%9B%B2%E7%BA%BF-secp256k1/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>椭圆曲线加密法是一种基于离散对数问题的非对称（或公钥） 加密法， 可以用对椭圆曲线上的点进行加法或乘法运算来表达。在Bitcoin中使用的是secp256k1这条椭圆曲线<br><a id="more"></a></p><h2 id="椭圆曲线"><a href="#椭圆曲线" class="headerlink" title="椭圆曲线"></a>椭圆曲线</h2><ul><li>y^2^mod p = x^2^ +ax+b mod p</li><li>a、b满足：4a^3^+27b^2^ mod p!=0 这保证了x^3^+ax+b不包含重复的因子，所以该曲线就可用于生成一个群组</li><li>在一个有限域Fp，素数阶p的有限域内</li><li>p=2^256^-2^32^-2^9^-2^8^-2^7^-2^6^-2^4^-1</li></ul><h2 id="椭圆曲线上的加法"><a href="#椭圆曲线上的加法" class="headerlink" title="椭圆曲线上的加法"></a>椭圆曲线上的加法</h2><p>P3=P1+P2<br>计算方法：P1和P2之间画一条线，恰好与椭圆曲线上的一点相交，记此点为：P3’=(x,y)，然后再x轴做映射的：P3=(x,-y)</p><h2 id="特殊的情况"><a href="#特殊的情况" class="headerlink" title="特殊的情况"></a>特殊的情况</h2><ul><li>P1与P2为同一点，P1和P2之间的连线为P1的切线，曲线上有且只有一个新的点与该切线相交</li><li>P1和P2具有相同的x值，但不同的y值，则切线会垂直，这种情况下，P3=“无穷远点”</li><li>若一点是无穷远点，则与其相加不变，无穷远点类比0处理</li></ul><h2 id="secp256k1"><a href="#secp256k1" class="headerlink" title="secp256k1"></a>secp256k1</h2><p>y^2^=x^3^+ax+b，其中a=0且b=7，就是曲线secp256k1<br>G是生成元，n是G的素数阶<br>则任取k，Q=k*G，则k为私钥，Q为公钥</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>占用很少的带宽和存储资源，秘钥的长度很短</li><li>让所有的用户都可以使用同样的操作完成域运算</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天看了一些关于BrainWellets的东西，感觉还蛮有意思的，明天要把它的来龙去脉都讲清楚了，技术尽量去看吧，然后再把整个PPT从头到尾慢慢品尝。</p>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> secp256k1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BrainWallets</title>
      <link href="/2020/02/11/Brain%20Wallets/"/>
      <url>/2020/02/11/Brain%20Wallets/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>今天粗读了这篇短论文：<a href="https://fc16.ifca.ai/preproceedings/36_Vasek.pdf" target="_blank" rel="noopener">2016The Bitcoin Brain Drain-A Short Paper on the Use and Abuse of Bitcoin Brain Wallets</a>大体了解了在比特币网络中使用BrainWallets的坏处，作者建议不要使用BrainWallets，这也是大脑钱包官网关闭的原因吧<br><a id="more"></a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>用户自己选定一些对自己有意义且能记住的字符串，然后通过简单地hash就可以生成自己的私钥，私钥经过两次哈希计算得到的值再经过base58编码即可得到address。说的有些粗略了，明天再补。。。<br>在BrainWallets中大体原理就像昨天说的这样，这也是为什么大脑钱包会被人们接收并使用，因为这样的方式确实方便人们使用比特币钱包，通过记住有意义的字符串，在使用的时候生成私钥就可以了，而不需要去记住繁琐且冗长的私钥，但是同样的字符串就会生成相同的私钥，因为它的生成机制就是这样，并且用户的地址在比特币网络中公开，无论是谁都可以得到你的address，这也是容易受到攻击的原因吧，所以攻击者们就利用这点对用户的私钥进行破译。作者使用的是：<a href="https://rya.nc/brainflayer" target="_blank" rel="noopener">brainflayer</a>进行研究的。</p><h2 id="密码语料库"><a href="#密码语料库" class="headerlink" title="密码语料库"></a>密码语料库</h2><p>3000亿个候选密码，分别如下：<br>1.英语：Ubuntu 12.04附带的英语单词列表。<br>2.城市词典：来自人群的crowd语词典中的术语和短语7。 “  combinator工具用于检查所有成对的词。<br>3.两个单词：使用组合工具的英文单词对。<br>4.英语/ S语城市词典：城市词典中的单个单词条目与英语单词结合在一起。此外，运行结果通过组合工具可搜索所有长度不超过20个字符的短语。<br>5.英文维基百科<br>6.维基语录：2013年3月3日的英语，西班牙语，俄语和德语语录。<br>7.短语：WikiQuote，Wikipedia和Naxxatoe短语的排列。</p><ol><li>xkcd：2014年7月10日从三个来源获得的列表8。组合方式最多三个词，带空格和不带空格。所有单词用于2个单词组合；这三个列表共同使用的所有单词，用于3个单词组合。<br>9.歌词：可从<a href="https://andymoore.info/购买的歌词和歌曲标题mysql-lyrics-database" target="_blank" rel="noopener">https://andymoore.info/购买的歌词和歌曲标题mysql-lyrics-database</a> /。</li><li>Blockchain.info标签：从https获取的所有公共比特币地址标签： //blockchain.info/tags。<br>11.密码转储LinkedIn，MySpace，RockYou，Rootkit.com</li><li>Leet MRL：MySpace，Rockyou和LinkedIn的重复数据删除合并（因此MRL）转储，并使用精讲替代品。</li><li>Prince MRL：应用Prince攻击的MRL列表。<br>14.安全行业列表：CrackStation，Naxxatoe，Uniqpass（组合2012-01-01和2012-04-01列表），Skull Security9（RockYou列表除外）<br>通过使用<a href="https://rya.nc/brainflayer" target="_blank" rel="noopener">brainflayer</a>进行测试，与从比特币网络中提取出的地址进行比对，或者是排列组合，下面举几个例子：<br>6e24b1342852a8e4af3c63206f8b2266ba887ef6:u:str:1234<br>ec42ad7fd54f931274b83f6137379206e458b106:u:str:1satoshi<br>那些很长的数字密码都能被破解:<br>09b508bae503da42f05575891866d0072bcf65f6:u:str:011235813213455<br>32f6ace81715e0872e6db7ff4a280185205620a3:u:str:12345678901234567890<br>afe66e0314eb15a5cd01d95b94166ce995c3347d:u:str:000000000000000000000000000000<br>字母密码看起来15位以内的都没用，破解了太多了。<br>482bc0946efa74a5a3d005e693b2774e1aeb7dad:u:str:qwertyuiopasdfghjklzxcvbnm<br>4b1b231e9caa7f95d51ed7c99df68a5add5a1714:u:str:doandroidsdreamofelectricsheep<br>bf1f119153f6ecedb259f0043f9fbbc88687b22e:u:str:thepastisagrotesqueanimal<br>再看看有些很长的密码都能破解，有点心惊。<br>ac8dc3fcfa4e9e91dddfc0c3fe6d7e0021292036:u:str:may the force be with you<br>8b0a993126c3bf8f4b28c8264b553d6aa39f2956:u:str:Money is the root of all evil.<br>1622dc9d9e5423d7b84122f9ef7edfa1981d9960:u:str:nothing ventured nothing gained<br>0c7cdc2d447af8d422dd2b54cab2f274ca88131d:u:str:No one can make you feel inferior without your consent.<br>8ee2d47121c480c37f9dd0a88bddf2dc21b284da:u:str:The quick brown fox jumped over the lazy dog.<br>2029758fa9d81f9c36f4be2ab8696ad10fc602f8:u:str:The quick brown fox jumps over the lazy dog<br>838edc90c250d298fc115bf028164f105e228fb9:u:str:these aren’t the droids you’re looking for<br>8c4cfbd55dd01f6c221372eba1e57c7496d7239f:u:str:This is the way the world ends.<br>31ae15fc484cf5fd34ecd49e1afb51e3f2174a93:u:str:tomb-of-the-unknown-soldier-identification-badge<br>还有中文名做密码的<br>7afa3b687e58d3f16feccb8244b90a87a535b85c:u:str:试试看<br>73b1bebd338fc051dba7282d4f99846fac01df23:u:str:中国上海<br>这些结果转载自：<a href="http://www.huangzhong.ca/zh/bitcoin-brainwallet-cracking-tools/" target="_blank" rel="noopener">脑钱包破解工具实测</a></li></ol><h2 id="存在一些值的注意的字符串"><a href="#存在一些值的注意的字符串" class="headerlink" title="存在一些值的注意的字符串"></a>存在一些值的注意的字符串</h2><ul><li>one two three four five six seven</li><li>“”</li><li>how much wood could a woodchuck chuck if a woodchuck could<br>chuck wood<br>比如这上面的字符串就很容易破解，等等</li></ul><h2 id="怎样确定BrainWallets被盗"><a href="#怎样确定BrainWallets被盗" class="headerlink" title="怎样确定BrainWallets被盗"></a>怎样确定BrainWallets被盗</h2><p>作者通过对比特币网络中大脑钱包资金的流失速度进行统计发现了一些东西。<br>大脑钱包里面的资金流失速度非常快，通过统计发现一半的脑钱包的资金在21分钟之内耗尽，几乎所有的脑钱包中的资金在24小时内耗尽，其中有一些是由大脑钱包的所有者发起的，但是绝大多数情况并非如此。</p><h2 id="发现drainers"><a href="#发现drainers" class="headerlink" title="发现drainers"></a>发现drainers</h2><p>作者通过研究发现确实存在一些针对大脑钱包的drainers，并且在论坛中得到了证实。许多机器人监控新交易存入一直私钥的脑钱包中，会迅速将钱汇到自己的账户地址中去，如果都使用了相同的地址，这使得研究人员更容易记录他们的活动。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>不要使用大脑钱包，密码较弱的大脑钱包破译速度将更加迅速。</p>]]></content>
      
      
      <categories>
          
          <category> Bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BrainWallets </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blockchainr源码剖析</title>
      <link href="/2020/02/08/Blockchainr%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2020/02/08/Blockchainr%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在<a href="https://conference.hitb.org/hitbsecconf2014kul/materials/D1T1%20-%20Filippo%20Valsorda%20-%20Exploiting%20ECDSA%20Failures%20in%20the%20Bitcoin%20Blockchain.pdf" target="_blank" rel="noopener">2014HITB-Exploiting ECDSA Failures in the Bitcoin Blockchain</a>中他所使用提取签名的方法是通过Bloomfilter实现的，作者提到：</p><ul><li>first pass：把签名添加到Bloomfilter里面，作者所使用的是：<a href="https://github.com/bitly/dablooms" target="_blank" rel="noopener">dablooms</a>，如果过滤器中已经存在了该签名，则把该签名放到一个map中叫做：potentialValues</li><li>second pass：重新遍历signature，如果签名存在于potentialValues中，导出签名以及它的其他信息到map：rMap中</li></ul><hr><a id="more"></a><h4 id="小故事"><a href="#小故事" class="headerlink" title="小故事"></a>小故事</h4><p>最近看的这篇PPT，他主要是探讨的在Bitcoin中同一用户使用相同的随机数k会造成私钥的泄漏，进而造成账户金额被盗等重大问题。作者举了几个例子：</p><ul><li>索尼以前就犯过这样的错误：PlayStation 3 只能运行被索尼的进行ECDSA签名的游戏。如果我想为PlayStation 3开发了一个新的游戏，除非我从索尼获得签名值，否则我及时发布了，也运行不了这个游戏。问题是，索尼签名时用了一个静态的k值而不是随机生成的，这就可以根据相同的k进行破解从而得到私钥，进而任意发布游戏。<br><img src="/images/sony.png" alt="Sony&#39;s ECDSA code"></li><li>有人报告了他们的比特币被盗，并发送至地址：<a href="https://blockchain.info/address/1HKywxiL4JziqXrzLKhmB6a74ma6kxbSDj" target="_blank" rel="noopener">https://blockchain.info/address/1HKywxiL4JziqXrzLKhmB6a74ma6kxbSDj</a> 您可以看到该地址当前包含55.82152538被盗硬币。已经注意到，在客户通过重新使用相同的随机数来不正确地签署交易后的几个小时内，所有硬币都被转移了。<br><img src="/images/beidao.png" alt="stealer"> <a href="https://bitcointalk.org/index.php?topic=271486" target="_blank" rel="noopener">新闻链接</a></li><li>Android漏洞<br><img src="/images/Android.png" alt="Android"></li></ul><hr><p>下面具体展开对源码的剖析</p><h2 id="blockchainr"><a href="#blockchainr" class="headerlink" title="blockchainr"></a>blockchainr</h2><h3 id="代码整体架构"><a href="#代码整体架构" class="headerlink" title="代码整体架构"></a>代码整体架构</h3><ul><li>main函数</li><li>btcdbSetup函数</li><li>getSignatures函数</li><li>search函数</li></ul><h4 id="getSignature"><a href="#getSignature" class="headerlink" title="getSignature"></a>getSignature</h4><p>此函数的目的是导出区块中所有的Signature，作者定义了一个结构体，用于存放与签名相关的信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">type rData <span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">sig  *btcec.Signature</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">H    int64</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">Tx   <span class="keyword">int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">TxIn <span class="keyword">int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">Data <span class="keyword">int</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><ul><li>sig：签名(包含r、s)</li><li>H：交易所在区块的高度</li><li>Tx：区块中的第几笔交易</li><li>TxIn：交易中第几个TxIn</li><li>Data：</li></ul><p>该函数的返回值是这个类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function">func <span class="title">getSignatures</span><span class="params">(maxHeigth int64, <span class="built_in">log</span> btclog.Logger, db btcdb.Db)</span> chan *rData </span>&#123;&#125;</span></pre></td></tr></table></figure><p>具体过程就不说了，它主要就是通过一层层的循环将数据导出的(思想如下)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> block in chain:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> tx in block:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> input in tx:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr></table></figure><h4 id="search函数"><a href="#search函数" class="headerlink" title="search函数"></a>search函数</h4><p>使用dablooms这个Bloom过滤器，设置了容量、错误率等，都定义了常量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">tickFreq  = <span class="number">10</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">bloomSize = <span class="number">100000000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">bloomRate = <span class="number">0.005</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr></table></figure><p>这里作者设置的容量是100000000，我觉得在2014年这个数据容量应该足够了<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">filter := dablooms.NewScalingBloom(bloomSize, bloomRate, <span class="string">"blockchainr_bloom.bin"</span>)</span></pre></td></tr></table></figure><br>主要的提取过程前面提到了分为两步代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">step</span> == <span class="number">1</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">b := rd.sig.R.Bytes()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> filter.Check(b) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">matches++</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">potentialValues.Add(rd.sig.R.<span class="keyword">String</span>())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> !filter.Add(b, <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>.Warn(<span class="string">"Add failed (?)"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">step</span> == <span class="number">2</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> potentialValues.Contains(rd.sig.R.<span class="keyword">String</span>()) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">matches++</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">rMap[rd.sig.R.<span class="keyword">String</span>()] = append(rMap[rd.sig.R.<span class="keyword">String</span>()], rd)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>Signatures是调用getSignatures获得的，前文有提到过</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">signatures := getSignatures(maxHeigth, <span class="built_in">log</span>, db)<span class="comment">//获取签名</span></span></pre></td></tr></table></figure><ul><li>第一步，通过循环导出的signatures将签名R赋值给b然后通过过滤器过滤，判断签名是否在过滤器中出现过，如果出现过那么就把它添加到potentialValues中</li><li>第二步，再一次循环signatures判断R是否存在于第一步生成的集合potentialValues中，如果存在将其详细信息添加到rMap中，键值是签名R，也就是说如果存在重复的R就会添加进去多组相关信息。说一下rMap的类型：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">rMap := make(<span class="built_in">map</span>[<span class="built_in">string</span>][]*rData)</span></pre></td></tr></table></figure><p>key是string类型，value是rData类型的集合，所以它的索引中存储的是签名R，value是一个存储多组R的相关信息的集合，这样的话前面我说的应该也就明白了。最后search函数返回rMap</p><h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><p>首先给出了区块数据的路径以及数据库类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">var (</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">dataDir = flag.<span class="keyword">String</span>(<span class="string">"datadir"</span>, filepath.Join(btcutil.AppDataDir(<span class="string">"btcd"</span>, <span class="literal">false</span>), <span class="string">"data"</span>), <span class="string">"BTCD: Data directory"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">dbType  = flag.<span class="keyword">String</span>(<span class="string">"dbtype"</span>, <span class="string">"leveldb"</span>, <span class="string">"BTCD: Database backend"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">)</span></pre></td></tr></table></figure><p>之后通过btcdbSetup函数设置了btcdb：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>, db, dbCleanup := btcdbSetup(*dataDir, *dbType)</span></pre></td></tr></table></figure><p>再调用search函数导出区块中重复签名R以及它们的相关信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">duplicates := search(<span class="built_in">log</span>, db)<span class="comment">//返回值是rMap</span></span></pre></td></tr></table></figure><p>作者新定义一个与导出集合类型一致的map，(value是存储的该签名R相关的信息的一个数组，也就是说存储着多组不同的rData)这段代码非常重要，是作者整个思想的核心，通过循环判断value数组的长度是否大于一，若是则证明签名R是重复的，若不是则签名R不重复。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">realDuplicates := make(<span class="built_in">map</span>[<span class="built_in">string</span>][]*rData)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := range duplicates &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> len(v) &gt; <span class="number">1</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">realDuplicates[k] = v</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p>最后将上文代码中的realDuplicates导出成文件，至此完成了整个比特币网络中相同签名R及其相关信息的导出。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>作者阐述通过一系列的公式验算以及相关的新闻，我们不难发现这种根据相同的签名R来盗取比特币的行为确实存在过，所以我们知道了k的重要性，一定要保证k值的保密性、唯一性，文章后面一部分作者提到了解决方法，在生成随机数k的时候使用RFC 6979，k=SHA256(d + HASH(m))，通过私钥d，和消息m来生成随机数k，这样的话，d保证了其保密性，hash(m)又保证了其唯一性，所以整个公式已经满足了我们的需要。</p>]]></content>
      
      
      <categories>
          
          <category> Bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchainr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VerifyTransaction</title>
      <link href="/2020/02/07/VerifyTransaction/"/>
      <url>/2020/02/07/VerifyTransaction/</url>
      
        <content type="html"><![CDATA[<h2 id="比特币中的签名"><a href="#比特币中的签名" class="headerlink" title="比特币中的签名"></a>比特币中的签名</h2><p>签名存在于解锁脚本里面即ScriptSig，主要有身份认证，就是签名是用户使用私钥完成的，所以证明了花的钱是自己的，之后解锁脚本会去验证锁定脚本，进而解锁UTXO，所用到的也是sig和PubKey进行交易验证，验证成功即可完成交易产生新的UTXO。<br>那么在Bitcoin中验证交易的具体过程是怎样的呢？并且签名的类型也是多种：SIGHASH_ALL, SIGHASH_NONE, SIGHASH_SINGLE。今天我门主要探索的是SIGHASH_ALL中交易的验证过程。<br><a id="more"></a></p><h2 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h2><p>下图当成两张图片使用<br><img src="/images/TxPrev.png" alt="TxPrev and TxNew"></p><ul><li>创建subscript：从OP_CODESEPARATOR到脚本的最后<br><img src="/images/PrevTx_PKScript.png" alt="PrevTx_PKScript"></li><li>如果脚本中存在签名则移除</li><li>把操作码：OP_CODESEPARATORS从脚本中移除<br><img src="/images/remove_op.png" alt="remove"></li><li>把hashtype从签名中移除<br><img src="/images/hashtype.png" alt="hashtype"></li><li>复制一份TxNew命名为TxCopy</li><li>把TxCopy中的所有TxIn置空</li><li>复制Subscript到你要验证的TxIn中</li><li>序列化TxCopy并且扩展4字节hashTypeCode(使用的是sha256^2)</li><li>通过字符串验证签名(hash strings是big-endian)<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2>这一个比较细节的过程，希望以后能够用的到</li></ul>]]></content>
      
      
      <categories>
          
          <category> Bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> verifytransaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bloom filter</title>
      <link href="/2020/02/06/Bloomfilter/"/>
      <url>/2020/02/06/Bloomfilter/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Bloom filter是一个数据结构，它可以用来判断某个元素是否在集合内，具有运行快速、内存占用小的特点。<br>而高效插入和查询的代价就是Bloom filter是一个基于概率的数据结构，它只能告诉我们一个元素绝对不在集合内或可能在集合内，而不能告诉我们一定在集合内。<br><a id="more"></a></p><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>Bloom过滤器的实现是由⼀个可变⻓度（N）的二进制数组（N位⼆进制数构成⼀个位域）和数量可变（M）的一组哈希函数组成。这些哈希函数的输出值始终在1和N之间， 该数值与二进制数组相对应。 并且该函数为确定性函数， 也就是说任何一个使相同Bloom过滤器的节点通过该函数都能对特定输入得到同一个的结果。 Bloom过滤器的准确性和私密性能通过改变长度（N）和哈希函数的数量（M）来调节。<br><img src="/images/Bloomfilter.png" alt="Bloomfilter"></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>当Bloom过滤器中关键词增加时，它对应的某个哈希函数的输出值可能已经是1了，这种情况下，该位不会再次改变，所以会因为关键词的增加而导致准确性降低。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>我最近在做bitcoin中签名r的提取并作出比较，数据量非常大，所以我觉得使用Bloom filter会节省很大的时间，以后我要尝试一下。<br>今天学习到的一些东西：</p><ul><li>verify transaction具体的过程，近期更新</li><li>Brainwallets存在安全隐患，它的私钥是根据一串用户指定的字符哈希而来，PPT中说到它使用的是math.Random()，它的范围是0-1中的小数，而比特币钱包中私钥的生成是选取的不可预测或者不可重复的1-2^256中的随机数，之后我也会更新一下有关bitcoin中私钥公钥地址之间是怎样生成的。</li><li>发现了个新的东西：若k1-k2=c，且c已知，也可以造成泄漏，但是我还没看懂！看懂了再更新！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 小知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bloom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ECDSA</title>
      <link href="/2020/02/05/ECDSA/"/>
      <url>/2020/02/05/ECDSA/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>数字签名算法（DSA）在联邦信息处理标准FIPS中有详细论述，称为数字签名标准。它的安全性基于素域上的离散对数问题。椭圆曲线密码（ECC）由Neal Koblitz和Victor Miller于1985年发明。它可以看作是椭圆曲线对先前基于离散对数问题（DLP）的密码系统的模拟，只是群元素由素域中的元素数换为有限域上的椭圆曲线上的点。椭圆曲线密码体制的安全性基于椭圆曲线离散对数问题（ECDLP）的难解性。椭圆曲线离散对数问题远难于离散对数问题，椭圆曲线密码系统的单位比特强度要远高于传统的离散对数系统。因此在使用较短的密钥的情况下，ECC可以达到于DL系统相同的安全级别。这带来的好处就是计算参数更小，密钥更短，运算速度更快，签名也更加短小。因此椭圆曲线密码尤其适用于处理能力、存储空间、带宽及功耗受限的场合。<br><a id="more"></a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>ECDSA是ECC与DSA的结合，整个签名过程与DSA类似，所不一样的是签名中采取的算法为ECC，最后签名出来的值也是分为r,s。</p><h2 id="椭圆曲线的参数"><a href="#椭圆曲线的参数" class="headerlink" title="椭圆曲线的参数"></a>椭圆曲线的参数</h2><p>椭圆曲线算法是工作在循环子群上的，因此需要如下几个参数：</p><ul><li>素数p，这个值定义了有限域的大小</li><li>椭圆曲线的系数a、b</li><li>基点G，也称生成元</li><li>子群的阶n</li><li>cofactor h (h = N/n)</li></ul><h2 id="KeyGen"><a href="#KeyGen" class="headerlink" title="KeyGen"></a>KeyGen</h2><ul><li>G为椭圆曲线上的点，q是由G所组成的有限循环群的阶</li><li>选取随机数x，x属于[1,q-1]</li><li>计算Q=xG</li><li>私钥为：x，公钥为：Q</li></ul><hr><h2 id="Sign对消息m签名"><a href="#Sign对消息m签名" class="headerlink" title="Sign对消息m签名"></a>Sign对消息m签名</h2><ul><li>选取随机数k，k属于[1,q-1]</li><li>计算R=kG=(Rx,Ry)以及r=Rx mod q</li><li>计算s=k^-1(H(m)+rx) mod q，若r=0或s=0，则另选随机数k，重新执行上面的过程</li><li>消息m的签名为(r,s)</li></ul><hr><h2 id="Verif"><a href="#Verif" class="headerlink" title="Verif"></a>Verif</h2><ul><li>计算u=s^-1H(m) mod q, v=rs^-1 mod q</li><li>计算(x1,y1)=uG+vQ，r1=x1 mod q</li><li>判断r和r1的关系，如果r=r1，则签名有效，否则签名无效</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>不太会用Markdown的公式，所以先凑活写一下，以后会用了，再更新！</p><h2 id="ECDSA在Bitcoin中的应用"><a href="#ECDSA在Bitcoin中的应用" class="headerlink" title="ECDSA在Bitcoin中的应用"></a>ECDSA在Bitcoin中的应用</h2><p>主要应用于，transaction的签名，签名存放在解锁脚本的ScriptSig中，所以在签名中存在两个字段r，s。下面我们来具体分析下今天我看的东西。</p><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><ul><li>选取一个随机数d，计算Publickey=dG</li><li>e=hash(message)</li><li>选取一个随机数k</li><li>(x,y)=kG，r=x</li><li>s=(e+rd)/k<br>sig:(r,s)</li></ul><hr><p>看着似乎没有什么问题，但是我们如果使用同一个随机数k，即k1=k2</p><ul><li>(x1,y1)=k1G</li><li>(x2,y2)=k2G</li></ul><hr><h2 id="因为k1-k2，所以x1-x2，y1-y2，所以r1-r2"><a href="#因为k1-k2，所以x1-x2，y1-y2，所以r1-r2" class="headerlink" title="因为k1=k2，所以x1=x2，y1=y2，所以r1=r2"></a>因为k1=k2，所以x1=x2，y1=y2，所以r1=r2</h2><ul><li>sig1:[r,(e1+rd)/k]</li><li>sig2:[r,(e2+rd)/k]</li><li>s1=(e1+rd)/k，s2=(e2+rd)/k</li><li>两个等式左右同时相减得到：s1-s2=(e1-e2)/k，即：k=(e1-e2)/(s1-s2)</li><li>得到k之后就可以计算：d=(s1k-e1)/r</li></ul><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>综上所述，即可以得到私钥d，所以如果同一用户下的交易签名r字段相等，就可以得到私钥，进而造成账户金额被盗等重大问题，索尼以前就犯过这样的错误：PlayStation 3 只能运行被索尼的进行ECDSA签名的游戏。如果我想为PlayStation 3开发了一个新的游戏，除非我从索尼获得签名值，否则我及时发布了，也运行不了这个游戏。问题是，索尼签名时用了一个静态的k值而不是随机生成的。所以k的保密性非常重要，且random number也保证其唯一性。它只是介绍的在Bitcoin中，在其他的与Bitcoin相关的加密货币中是否也存在这样的情况，我还要进一步的研究，并且它只是考虑了在同一个用户下会出现这样的情况，那么在不同的用户呢，或者不仅仅是签名r相等呢！</p>]]></content>
      
      
      <categories>
          
          <category> Bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ECDSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zcash区块数据结构解析</title>
      <link href="/2020/02/04/Zcash%E5%8C%BA%E5%9D%97%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/02/04/Zcash%E5%8C%BA%E5%9D%97%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Zcash（ZEC）由Zooko Wilcox-O’Hearn于2016年推出，基于Zerocoin协议，Zcash（ZEC）是一种去中心化，开放源代码，以隐私为重点的加密货币，可实现交易的选择性透明化。Zcash交易可以是透明的，也可以通过称为zk-SNARKs的零知识证明来屏蔽。这允许网络维护余额的安全分类帐，而无需透露各方或涉及的金额。代替发布支出授权和交易值，对交易元数据进行加密，并使用zk-SNARK证明没有人是不诚实的。<br><a id="more"></a></p><h2 id="Zcash区块的结构"><a href="#Zcash区块的结构" class="headerlink" title="Zcash区块的结构"></a>Zcash区块的结构</h2><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="/images/Zcash_block.png" alt="Zcash_block"></p><h3 id="Block-Header"><a href="#Block-Header" class="headerlink" title="Block Header"></a>Block Header</h3><ul><li>nVersion：版本号。</li><li>hashPrevBlock：前一个区块的哈希值。</li><li>hashMerkleRoot：内部字节顺序的SHA-256d哈希。 merkle根源自此块中包含的所有事务的哈希值，从而确保在不修改header的情况下不能修改这些事务。</li><li>hashReserved /hashFinalSaplingRoot：</li><li>nTime：时间戳，旷工打包区块的时间。</li><li>nBits：工作量证明的难度目标。</li><li>nNonce：随机数，用于工作量证明，矿工可以更改其任意字段以修改标头哈希，以产生小于或等于目标阈值的哈希。</li><li>solutionSize：Equihash解决方案的大小（以字节为单位）。</li><li>solution：Equihash解决方案</li></ul><h3 id="transactions"><a href="#transactions" class="headerlink" title="transactions"></a>transactions</h3><ul><li>header：(version&gt;=1)</li><li>nVersionGroupId：版本组ID(version&gt;=3)</li><li>tx_in_count：此交易的输入数量(version&gt;=1)</li><li>tx_in：交易输入（与bitcoin类似）(version&gt;=1)</li><li>tx_out_count：此交易的输出数量(version&gt;=1)</li><li>tx_out：交易输出（与bitcoin类似）(version&gt;=1)</li><li>lock_time：锁定交易的时间(version&gt;=1)</li><li>nExpiryHeight：块高度在{1 .. 499999999}范围内，之后交易将到期，或者为0以禁用到期时间(version&gt;=3)</li><li>valueBalance：sapling花费的值减去output的值（对Zcash的交易过程不懂，所以不太懂这个的定义）(version&gt;=4)</li><li>nShieldedSpend：</li><li>vShieldedSpend：</li><li>nShieldedOutput：</li><li>vShieldedOutput：</li><li>nJoinSplit：</li><li>vJoinSplit：</li><li>vJoinSplit：</li><li>joinSplitPubKey：JoinSplitSig公共验证密钥的编码(version&gt;=2)</li><li>joinSplitSig：对整个TransacTion数据使用私钥进行的签名(version&gt;=2)</li><li>bindingSig：是整个Transaction数据的签名(verson&gt;=4)</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>今天一开始想学习的是XRP（瑞波币），了解了一番，大体知道它的优点：</p><ul><li>打包一个区块的时间仅需几秒钟，而比特币需要10分钟</li><li>交易记录的确认方式更加快速，所有节点一起确认，仅仅需要3至5秒钟，而比特币是一个节点一个节点的确认，速度大大降低，需要40至50分钟<br>此外还了解到，XRP是一个去中心化、覆盖全货币币种的互联网金融交易系统，它的网关是资金进出如波系统的进出口，人们可以通过这个中介将各类货币注入或者抽离瑞波系统，它的货币供应量是1000亿。<br>本来是想先把它的区块结构图画出来的，结果寻找半天无果，我也想过通过分析源码找出结构代码，但是能力有限，好在Zcash有一篇白皮书让我找到了，这才得到了区块结构，慢慢深入了解Zcash的交易过程吧，进而完善blog！</li></ul>]]></content>
      
      
      <categories>
          
          <category> 区块结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Zcash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ETH区块数据结构解析</title>
      <link href="/2020/02/01/ETH%E5%8C%BA%E5%9D%97%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/02/01/ETH%E5%8C%BA%E5%9D%97%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="区块的源码"><a href="#区块的源码" class="headerlink" title="区块的源码"></a>区块的源码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Block represents an entire block in the Ethereum blockchain.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">type Block <span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    header       *Header</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    uncles       []*Header</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    transactions Transactions</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// caches</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    hash atomic.Value</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">size</span> atomic.Value</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Td is used by package core to store the total difficulty</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// of the chain up to and including the block.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    td *big.Int</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// These fields are used by package eth to track</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// inter-peer block relay.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    ReceivedAt   time.Time</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    ReceivedFrom interface&#123;&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><a id="more"></a><ul><li>header：区块头，包含该区块的信息</li><li>uncles：该区块所包含的叔块的信息</li><li>transactions：该区块包含的交易信息</li><li>td：总难度，即从开始区块到本区块（包括本区块）所有的难度的累加</li><li>ReceivedAt：用于跟踪区块的生成  </li><li>ReceivedFrom：用于跟踪区块的生成</li></ul><h2 id="结构图："><a href="#结构图：" class="headerlink" title="结构图："></a>结构图：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">type Header <span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    ParentHash  common.Hash    `json:<span class="string">"parentHash"</span>       gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    UncleHash   common.Hash    `json:<span class="string">"sha3Uncles"</span>       gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    Coinbase    common.Address `json:<span class="string">"miner"</span>            gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    Root        common.Hash    `json:<span class="string">"stateRoot"</span>        gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    TxHash      common.Hash    `json:<span class="string">"transactionsRoot"</span> gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    ReceiptHash common.Hash    `json:<span class="string">"receiptsRoot"</span>     gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    Bloom       Bloom          `json:<span class="string">"logsBloom"</span>        gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    Difficulty  *big.Int       `json:<span class="string">"difficulty"</span>       gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    Number      *big.Int       `json:<span class="string">"number"</span>           gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    GasLimit    uint64         `json:<span class="string">"gasLimit"</span>         gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    GasUsed     uint64         `json:<span class="string">"gasUsed"</span>          gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    Time        *big.Int       `json:<span class="string">"timestamp"</span>        gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    Extra       []<span class="keyword">byte</span>         `json:<span class="string">"extraData"</span>        gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    MixDigest   common.Hash    `json:<span class="string">"mixHash"</span>          gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    Nonce       BlockNonce     `json:<span class="string">"nonce"</span>            gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">type Body <span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    Transactions []*Transaction</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    Uncles       []*Header</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><img src="/images/ETH_block.png" alt="ETH_block"></p><h3 id="各部分代表的含义"><a href="#各部分代表的含义" class="headerlink" title="各部分代表的含义"></a>各部分代表的含义</h3><ul><li>ParentHash：父区块的哈希值</li><li>UncleHash：上面提到的uncles的RLP哈希值，uncles是一个Header数组</li><li>Coinbase：挖出该区块矿工的地址，矿工费和挖出区块的奖励会发放到该地址</li><li>Root：存储账户状态的Merkle树的根节点的哈希</li><li>TxHash：存储该区块中交易的Merkle树的根节点的哈希</li><li>ReceiptHash：存储该区块的交易的回单的Merkle树的根节点的哈希，Block的所有Transaction执行完后会生成一个Receipt数组</li><li>Bloom：交易日志的布隆过滤器，用于查询</li><li>Difficulty：区块的难度</li><li>Number：区块高度</li><li>Time：挖出该区块的时间戳</li><li>GasLimit：区块内所有Gas消耗的上限</li><li>GasUsed：执行区块内所有Transaction实际消耗的Gas总和</li><li>Nonce：一个64bit的哈希数，用于工作量证明</li><li>mixDigest：该哈希值与Nonce值一起证明该区块上已经进行了足够的计算，用于证明挖矿成功</li><li>Extra：预留备用</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以太坊各个方面我也不太清楚，只能靠着自己了解的写一下，transaction的结构图没有给出，慢慢来吧，等我了解清楚再更新！</p><h2 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//core/types/transaction.go</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">type Transaction <span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    data txdata</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// caches</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    hash atomic.Value</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">size</span> atomic.Value</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    from atomic.Value</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">type txdata <span class="class"><span class="keyword">struct</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    AccountNonce uint64          `json:<span class="string">"nonce"</span>    gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    Price        *big.Int        `json:<span class="string">"gasPrice"</span> gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    GasLimit     uint64          `json:<span class="string">"gas"</span>      gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    Recipient    *common.Address `json:<span class="string">"to"</span>       rlp:<span class="string">"nil"</span>` <span class="comment">// nil means contract creation</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    Amount       *big.Int        `json:<span class="string">"value"</span>    gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    Payload      []<span class="keyword">byte</span>          `json:<span class="string">"input"</span>    gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Signature values</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    V *big.Int `json:<span class="string">"v"</span> gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    R *big.Int `json:<span class="string">"r"</span> gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    S *big.Int `json:<span class="string">"s"</span> gencodec:<span class="string">"required"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// This is only used when marshaling to JSON.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    Hash *common.Hash `json:<span class="string">"hash"</span> rlp:<span class="string">"-"</span>`</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><p><img src="/images/ETH_transaction.png" alt="ETH_transaction"></p><h3 id="trsansaction及txdata中各个部分的含义"><a href="#trsansaction及txdata中各个部分的含义" class="headerlink" title="trsansaction及txdata中各个部分的含义"></a>trsansaction及txdata中各个部分的含义</h3><h4 id="transaction"><a href="#transaction" class="headerlink" title="transaction"></a>transaction</h4><ul><li>data 它的格式是txdata，是交易所包含的数据txdata中详细讲</li><li>hash、size、from是缓存</li></ul><h4 id="txdata"><a href="#txdata" class="headerlink" title="txdata"></a>txdata</h4><ul><li>AccountNonce：此交易的发送者已发送过的交易数</li><li>Price：此交易的 gas price</li><li>GasLimit：本交易允许消耗的最大 gas 数量</li><li>Recipient：交易的接收者地址</li><li>Amount：交易转移的以太币数量，单位是 wei</li><li>Payload：交易可以携带的数据，在不同类型的交易中有不同的含义</li><li>V R S：交易的签名数据</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我感觉ETH的整个交易过程好复杂，没有静下心来好好研究下，有很多东西也是一窍不通，通过以上的总结，以太坊的区块结构大体解析的差不多了，还有很多东西值得研究，比如它使用的树的结构：Merkle-PatriciaTrie，以后再细细品味吧！</p>]]></content>
      
      
      <categories>
          
          <category> 区块结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ETH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo next主题中添加播放器Aplayer</title>
      <link href="/2020/01/31/Hexo%20next%E4%B8%BB%E9%A2%98%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%92%AD%E6%94%BE%E5%99%A8Aplayer/"/>
      <url>/2020/01/31/Hexo%20next%E4%B8%BB%E9%A2%98%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%92%AD%E6%94%BE%E5%99%A8Aplayer/</url>
      
        <content type="html"><![CDATA[<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ul><li>首先，先下载Aplayer源码：<a href="https://github.com/MoePlayer/APlayer" target="_blank" rel="noopener">APlayer</a></li></ul><h2 id="dist文件夹"><a href="#dist文件夹" class="headerlink" title="dist文件夹"></a>dist文件夹</h2><ul><li>再将文件中的dist文件夹复制到路径：<code>blog/themes/next/source</code>（我的next版本是7.5）<a id="more"></a></li></ul><h2 id="新建music-js"><a href="#新建music-js" class="headerlink" title="新建music.js"></a>新建music.js</h2><ul><li>在目录<code>blog/themes/next/source/dist</code>下添加music.js文件<br>内容是：</li></ul><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ap = <span class="keyword">new</span> APlayer(&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    container: document.getElementById('aplayer'),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    fixed: <span class="literal">true</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    autoplay: <span class="literal">true</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    audio: [</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        name: '勇气',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        artist: '棉子',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        url: 'http://music.163.com/song/media/outer/url?id=1411358329.mp3',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        cover: '/images/5.jpg',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        name: <span class="string">"星星"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        artist: '张杰',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        url: 'http://music.163.com/song/media/outer/url?id=1399004693.mp3',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        cover: '/images/xingxing.jpg',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        name: '这就是爱吗',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        artist: '十豆',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        url: 'http://music.163.com/song/media/outer/url?id=1412242872.mp3',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        cover: '/images/zjsam.jpg',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">      &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        name: 'Alone',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        artist: 'Alan Walker / Noonie Bao',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        url: 'http://music.163.com/song/media/outer/url?id=444269135.mp3',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        cover: '/images/alone.jpg',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        name: 'Umbrella (Matte Remix)',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        artist: 'Matte / Ember Island',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        url: 'http://music.163.com/song/media/outer/url?id=164209623.mp3',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        cover: '/images/1.jpg',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        name: '大眠 (完整版)原唱：王心凌',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        artist: '小乐哥',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        url: 'http://music.163.com/song/media/outer/url?id=3778678.mp3',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        cover: '/images/2.jpg',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        name: '世间美好与你环环相扣',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        artist: '柏松',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">        url: 'http://music.163.com/song/media/outer/url?id=1363948882.mp3',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">        cover: '/images/3.jpg',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">      &#125;,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">  &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">        name: <span class="string">'飞'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        artist: '王恩信Est / 二胖u',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">        url: 'http://music.163.com/song/media/outer/url?id=1386259535.mp3',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">        cover: '/images/4.jpg',</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">    ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure></h2><p>注：里面的代码可以修改，歌曲信息需要手动添加：</p><ul><li>name：歌曲名称</li><li>artist：作者</li><li>url：连接（具体怎样操作看下面步骤）</li><li>cover：是图片连接，可以是本地图片，也可以是在线图片，本地放在<code>source/images</code>然后修改路径即可</li></ul><hr><h2 id="url添加歌曲方法"><a href="#url添加歌曲方法" class="headerlink" title="url添加歌曲方法"></a>url添加歌曲方法</h2><ul><li>网易云网页播放一首歌曲</li><li>将网址中的id复制例：<code>https://music.163.com/#/song?id=1411358329</code></li><li>将下面代码中的id修改为你想添加歌曲的id：<code>http://music.163.com/song/media/outer/url?id=.mp3</code></li></ul><h2 id="修改文件-layout-swig"><a href="#修改文件-layout-swig" class="headerlink" title="修改文件_layout.swig"></a>修改文件_layout.swig</h2><p>在路径：<code>blog/themes/next/layout</code>下找到_layout.swig文件，然后将下面的代码添加到：<code>&lt;body itemscope ...&gt;</code>在body里面就可以</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> href=<span class="string">"/dist/APlayer.min.css"</span>&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"aplayer"</span>&gt;&lt;/div&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/dist/APlayer.min.js"</span>&gt;&lt;/script&gt;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"/dist/music.js"</span>&gt;&lt;/script&gt;</span></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>然后<code>hexo g</code>再<code>hexo d</code>在网页的左下角就可以看到了，大功告成！</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Bitcoin中提取部分签名字段R（1）</title>
      <link href="/2020/01/22/%E4%BB%8EBitcoin%E4%B8%AD%E6%8F%90%E5%8F%96%E9%83%A8%E5%88%86%E7%AD%BE%E5%90%8D%E5%AD%97%E6%AE%B5R1/"/>
      <url>/2020/01/22/%E4%BB%8EBitcoin%E4%B8%AD%E6%8F%90%E5%8F%96%E9%83%A8%E5%88%86%E7%AD%BE%E5%90%8D%E5%AD%97%E6%AE%B5R1/</url>
      
        <content type="html"><![CDATA[<h2 id="有关Bitcoin中部分签名的提取"><a href="#有关Bitcoin中部分签名的提取" class="headerlink" title="有关Bitcoin中部分签名的提取"></a>有关Bitcoin中部分签名的提取</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&ensp;&ensp;&ensp;&ensp;刚刚接触Bitcoin Wallet 里面的构造还不是很清楚，提取和解析指令也不是很熟悉，所以听到这个题目，有些无从下手，于是我先熟悉了bitcoin-cli的指令，例如：getblockhash + 区块高度、getblock + blockhash、getrawtransaction + Tx、decoderawtransaction + (getrawtransaction所获得的字符串)，想要获得签名r主要是通过这些指令，之后我学习了解析交易字符串后的各部分所代表的含义，通过学习精通比特币，我了解到在交易过程中，存在解锁脚本和锁定脚本，结合解析出的信息，我发现里面存在scriptSig这个字段名，但是里面存在两个字段：asm和hex，深入了解后发现，hex代表的是签名脚本的16进制字符串，至此我找到了目标提取字符串。下面具体介绍提取过程。<br><a id="more"></a></p><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>&ensp;&ensp;&ensp;&ensp;提取出比特币钱包所有签名字段中的r，并找到相同的签名r。</p><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><h5 id="UTXO"><a href="#UTXO" class="headerlink" title="UTXO"></a>UTXO</h5><p>&ensp;&ensp;&ensp;&ensp;比特币交易的基本单位是未经使用的一个交易输出UTXO。它是不可再分割的，在比它的金额还小的交易中就会存在找零行为，即会产生多个输出。实际上，并不存在存储比特币账户金额的地点，只有被所有者锁住的、分散在比特币网络中的UTXO。</p><h5 id="锁定脚本"><a href="#锁定脚本" class="headerlink" title="锁定脚本"></a>锁定脚本</h5><p>&ensp;&ensp;&ensp;&ensp;放在交易输出上的一个障碍，给出了花费UTXO的条件，一般包含条件操作符和限定公钥。</p><h5 id="解锁脚本"><a href="#解锁脚本" class="headerlink" title="解锁脚本"></a>解锁脚本</h5><p>&ensp;&ensp;&ensp;&ensp;是一个满足是锁定脚本限定条件的脚本，从而允许锁定的UTXO被花费，它也是交易输出的一部分，一般包含数字签名和对应公钥。</p><h6 id="比特币交易的具体过程"><a href="#比特币交易的具体过程" class="headerlink" title="比特币交易的具体过程"></a>比特币交易的具体过程</h6><p><img src="https://img-blog.csdnimg.cn/20200117231437525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="Transaction"><br>&ensp;&ensp;&ensp;&ensp;当userB给userC发送btc时，会新产生UTXO，观察图中的橙色连线，我们发现，新产生的UTXO中的in中scriptSig的公钥与之前的UTXO中scriptPubKey的公钥相同，其实在交易的过程中，解锁脚本需要满足未花费UTXO锁定脚本的条件，通过脚本语言验证，也就是之前交易的输出，证明是其拥有者，即可将其中的比特币调出，生成新的交易输出。所以交易过程中签名就存放在解锁脚本里面，后面通过解析交易字符串，我们就可以明确的找到scriptSig的所在了。</p><h5 id="ECDSA"><a href="#ECDSA" class="headerlink" title="ECDSA"></a>ECDSA</h5><p>&ensp;&ensp;&ensp;&ensp;在比特币系统中，所采用的是椭圆曲线数字签名算法来对交易进行签名。签名会产生两部分：r、s</p><h5 id="解析交易字符串及部分字段的含义"><a href="#解析交易字符串及部分字段的含义" class="headerlink" title="解析交易字符串及部分字段的含义"></a>解析交易字符串及部分字段的含义</h5><p><img src="https://img-blog.csdnimg.cn/20200117231828793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="scriptSig"><br>vin：交易输入数组<br>&ensp;&ensp;txid：交易ID<br>&ensp;&ensp;vout：交易输出序号<br>&ensp;&ensp;&ensp;&ensp;scriptSig：签名脚本<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;asm：签名脚本的汇编码<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;hex：签名脚本的16进制字符串表示<br>&ensp;&ensp;sequence：输入序列号<br>发现scriptSig中存在两个字段asm和hex，签名r到底在哪个字段里面呢？</p><h5 id="Transaction字符串的详解含义图"><a href="#Transaction字符串的详解含义图" class="headerlink" title="Transaction字符串的详解含义图"></a>Transaction字符串的详解含义图</h5><p><img src="https://img-blog.csdnimg.cn/20200117232116798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="TransactionAll"><br><strong>ScriptSig</strong><br><img src="https://img-blog.csdnimg.cn/20200117232230699.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="ScriptSig"><br>&ensp;&ensp;&ensp;&ensp;Lr的含义是签名r的长度，且每个小长方形代表两个字符，所以我们可以通过计算得到签名r的长度，从而可从字符串中截取出来。<br><strong>举个实例看一下：</strong><br>hex<br>4830450221<strong>00d71db39ae4f6bc3128d78661f6951bb17b097ab32e1ead3ce6fe761914715dd5</strong>02201970b34d36a9fef053b8b7a3c4555ef5bba14a88992449b980aee862465d966e01410404ac8c30c4e85f47702bfa8d8d56d8e614258958d6655611474da6cadb8c73195dc7951db3466caabd256ebc9f6ef87fcdb597b6cb048dd1bbf011713690ba19<br>其中黑体部分就是签名字段中的R<br>&ensp;&ensp;&ensp;&ensp;<strong>Lr=οχ21⟹32byte⇒32×8=256bit⇒256÷4=64</strong><br>&ensp;&ensp;&ensp;&ensp;所以可以得出签名r的长度是64，即在21之后的64个字符为签名r<br>至此，我们找到了需要提取的内容，我们可以通过编写脚本语言将其导出，但是截止2020年1月10日，整个比特币钱包的大小为300G，所拥有的的区块数目是612345，数据量较大，不容易导出。</p><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>&ensp;&ensp;&ensp;&ensp;主要任务就是将数据导出，刚开始没有一点思路，慢慢地发现可以通过编写python代码，将数据导入到指定文件中去，一开始我是直接在服务器上写代码，将hex导出到文件中去，但是不知道如何将文件放到本地，并且通过指令操作文件、运行代码比较麻烦，就找到了另外一种方法，pycharm可以连接到服务器，可以对服务器上代码以及文件直接操作即可，但是比特币网络中的数据量太大，想要导出签名所需要耗费的时间太多，目前我只导出了前610000个区块的tx，后续导出签名的代码出现问题，还在修改中，希望能尽快导出所有的签名R。</p>]]></content>
      
      
      <categories>
          
          <category> Bitcoin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bitcoin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bitcoin 区块结构解析</title>
      <link href="/2020/01/22/bitcoin%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/"/>
      <url>/2020/01/22/bitcoin%E5%8C%BA%E5%9D%97%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="区块的结构"><a href="#区块的结构" class="headerlink" title="区块的结构"></a>区块的结构</h2><p>区块分为：区块头和区块体<br><a id="more"></a></p><h4 id="区块头"><a href="#区块头" class="headerlink" title="区块头"></a>区块头</h4><p>区块头包括三组元数据：</p><ul><li>用于连接前面的区块、索引自父区块哈希值的数据。</li><li>挖矿难度、Nonce（随机数，用于工作量证明算法的随机数）、时间戳（当前区块的生成时间）</li><li>能够总结并快速归纳校验区块中所有交易数据的Merkle树根</li></ul><h4 id="区块体"><a href="#区块体" class="headerlink" title="区块体"></a>区块体</h4><p>主要包含交易数据tx</p><h4 id="区块结构图："><a href="#区块结构图：" class="headerlink" title="区块结构图："></a>区块结构图：</h4><p><img src="https://img-blog.csdnimg.cn/20200122235043793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM1MzI0MDU3,size_16,color_FFFFFF,t_70" alt="block"></p><h4 id="交易结构图："><a href="#交易结构图：" class="headerlink" title="交易结构图："></a>交易结构图：</h4><p><img src="/images/transaction.png" alt="transaction"></p><h4 id="区块的第一笔交易：coinbase交易结构"><a href="#区块的第一笔交易：coinbase交易结构" class="headerlink" title="区块的第一笔交易：coinbase交易结构"></a>区块的第一笔交易：coinbase交易结构</h4><p><img src="/images/coinbase.png" alt="coinbase"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>2020.1.16——2020.1.23<br>这段时间主要完成了Bitcoin结构的分析及作图、和对前面提取签名工作的总结，目前代码编写出现问题，需要花时间去找到方法解决，之后会继续更新其他具有隐私保护能力的密码货币的区块结构图。</p>]]></content>
      
      
      <categories>
          
          <category> 区块结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bitcoin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/12/01/hello-world/"/>
      <url>/2019/12/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ hexo server</span></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ hexo generate</span></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
